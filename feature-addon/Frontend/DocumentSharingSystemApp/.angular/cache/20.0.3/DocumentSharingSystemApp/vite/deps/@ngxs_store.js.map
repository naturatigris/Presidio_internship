{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-internals.mjs", "../../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-plugins.mjs", "../../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-operators.mjs", "../../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { assertInInjectionContext, inject, DestroyRef, RuntimeError, Injector, assertNotInReactiveContext, signal, PendingTasks } from './root_effect_scheduler-CWV89N3_.mjs';\nimport { getOutputDestroyRef, effect, untracked, computed, resource, encapsulateResourceError } from './resource-DalzMB4W.mjs';\nimport './primitives/di.mjs';\nimport './signal-nCiHhWf6.mjs';\nimport '@angular/core/primitives/di';\nimport '@angular/core/primitives/signals';\nimport './untracked-DmD_2MlC.mjs';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi 19.0\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable((subscriber) => {\n        if (destroyRef.destroyed) {\n            subscriber.next();\n            return;\n        }\n        const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    source;\n    destroyed = false;\n    destroyRef = inject(DestroyRef);\n    constructor(source) {\n        this.source = source;\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: (value) => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi 19.0\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi 19.0\n */\nfunction outputToObservable(ref) {\n    const destroyRef = getOutputDestroyRef(ref);\n    return new Observable((observer) => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe((v) => observer.next(v));\n        return () => {\n            subscription.unsubscribe();\n            unregisterOnDestroy?.();\n        };\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @publicApi 20.0\n */\nfunction toObservable(source, options) {\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(toObservable);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nfunction toSignal(source, options) {\n    typeof ngDevMode !== 'undefined' &&\n        ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    if (ngDevMode && requiresCleanup && !options?.injector) {\n        assertInInjectionContext(toSignal);\n    }\n    const cleanupRef = requiresCleanup\n        ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n        : null;\n    const equal = makeToSignalEqual(options?.equal);\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });\n    }\n    let destroyUnregisterFn;\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: (error) => {\n            state.set({ kind: 2 /* StateKind.Error */, error });\n            destroyUnregisterFn?.();\n        },\n        complete: () => {\n            destroyUnregisterFn?.();\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    }, { equal: options?.equal });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nfunction pendingUntilEvent(injector) {\n    if (injector === undefined) {\n        ngDevMode && assertInInjectionContext(pendingUntilEvent);\n        injector = inject(Injector);\n    }\n    const taskService = injector.get(PendingTasks);\n    return (sourceObservable) => {\n        return new Observable((originalSubscriber) => {\n            // create a new task on subscription\n            const removeTask = taskService.add();\n            let cleanedUp = false;\n            function cleanupTask() {\n                if (cleanedUp) {\n                    return;\n                }\n                removeTask();\n                cleanedUp = true;\n            }\n            const innerSubscription = sourceObservable.subscribe({\n                next: (v) => {\n                    originalSubscriber.next(v);\n                    cleanupTask();\n                },\n                complete: () => {\n                    originalSubscriber.complete();\n                    cleanupTask();\n                },\n                error: (e) => {\n                    originalSubscriber.error(e);\n                    cleanupTask();\n                },\n            });\n            innerSubscription.add(() => {\n                originalSubscriber.unsubscribe();\n                cleanupTask();\n            });\n            return innerSubscription;\n        });\n    };\n}\n\nfunction rxResource(opts) {\n    if (ngDevMode && !opts?.injector) {\n        assertInInjectionContext(rxResource);\n    }\n    return resource({\n        ...opts,\n        loader: undefined,\n        stream: (params) => {\n            let sub;\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\n            // optimization).\n            const onAbort = () => sub.unsubscribe();\n            params.abortSignal.addEventListener('abort', onAbort);\n            // Start off stream as undefined.\n            const stream = signal({ value: undefined });\n            let resolve;\n            const promise = new Promise((r) => (resolve = r));\n            function send(value) {\n                stream.set(value);\n                resolve?.(stream);\n                resolve = undefined;\n            }\n            // TODO(alxhub): remove after g3 updated to rename loader -> stream\n            const streamFn = opts.stream ?? opts.loader;\n            if (streamFn === undefined) {\n                throw new RuntimeError(990 /* ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION */, ngDevMode && `Must provide \\`stream\\` option.`);\n            }\n            sub = streamFn(params).subscribe({\n                next: (value) => send({ value }),\n                error: (error) => {\n                    send({ error: encapsulateResourceError(error) });\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n                complete: () => {\n                    if (resolve) {\n                        send({\n                            error: new RuntimeError(991 /* ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\n                        });\n                    }\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n            });\n            return promise;\n        },\n    });\n}\n\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal };\n\n", "import * as i0 from '@angular/core';\nimport { InjectionToken, inject, DestroyRef, Injectable, untracked } from '@angular/core';\nimport { BehaviorSubject, Subject, Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n// This key is used to store metadata on state classes,\n// such as actions and other related information.\nconst ɵMETA_KEY = 'NGXS_META';\n// This key is used to store options on state classes\n// provided through the `@State` decorator.\nconst ɵMETA_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n// This key is used to store selector metadata on selector functions,\n// such as decorated with the `@Selector` or provided through the\n// `createSelector` function.\nconst ɵSELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n\n// Property reads are not minified.\n// It's smaller to read it once and use a function.\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nconst ɵhasOwnProperty = (target, key) => _hasOwnProperty.call(target, key);\nconst ɵdefineProperty = Object.defineProperty;\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ɵensureStoreMetadata(target) {\n  if (!ɵhasOwnProperty(target, ɵMETA_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    ɵdefineProperty(target, ɵMETA_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return ɵgetStoreMetadata(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction ɵgetStoreMetadata(target) {\n  return target[ɵMETA_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ɵensureSelectorMetadata(target) {\n  if (!ɵhasOwnProperty(target, ɵSELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    ɵdefineProperty(target, ɵSELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return ɵgetSelectorMetadata(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction ɵgetSelectorMetadata(target) {\n  return target[ɵSELECTOR_META_KEY];\n}\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can\n  // determine equality as fast as possible.\n  const length = prev.length;\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nfunction ɵmemoize(func, equalityCheck = Object.is) {\n  let lastArgs = null;\n  let lastResult = null;\n  // we reference arguments instead of spreading them for performance reasons\n  function memoized() {\n    // eslint-disable-next-line prefer-rest-params\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      // eslint-disable-next-line prefer-rest-params, prefer-spread\n      lastResult = func.apply(null, arguments);\n    }\n    // eslint-disable-next-line prefer-rest-params\n    lastArgs = arguments;\n    return lastResult;\n  }\n  memoized.reset = function () {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n  return memoized;\n}\nclass StateToken {\n  _name;\n  constructor(_name) {\n    this._name = _name;\n    const selectorMetadata = ɵensureSelectorMetadata(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this._name);\n    };\n  }\n  getName() {\n    return this._name;\n  }\n  toString() {\n    return `StateToken[${this._name}]`;\n  }\n}\nclass ɵInitialState {\n  static _value = {};\n  static set(state) {\n    this._value = state;\n  }\n  static pop() {\n    const state = this._value;\n    this._value = {};\n    return state;\n  }\n}\nconst ɵINITIAL_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INITIAL_STATE_TOKEN' : '', {\n  providedIn: 'root',\n  factory: () => ɵInitialState.pop()\n});\nclass ɵNgxsAppBootstrappedState extends BehaviorSubject {\n  constructor() {\n    super(false);\n    const destroyRef = inject(DestroyRef);\n    // Complete the subject once the root injector is destroyed to ensure\n    // there are no active subscribers that would receive events or perform\n    // any actions after the application is destroyed.\n    destroyRef.onDestroy(() => this.complete());\n  }\n  bootstrap() {\n    this.next(true);\n  }\n  /** @nocollapse */\n  static ɵfac = function ɵNgxsAppBootstrappedState_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵNgxsAppBootstrappedState)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵNgxsAppBootstrappedState,\n    factory: ɵNgxsAppBootstrappedState.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵNgxsAppBootstrappedState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n// These tokens are internal and can change at any point.\nconst ɵNGXS_STATE_FACTORY = /* @__PURE__ */new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ɵNGXS_STATE_FACTORY' : '');\nconst ɵNGXS_STATE_CONTEXT_FACTORY = /* @__PURE__ */new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ɵNGXS_STATE_CONTEXT_FACTORY' : '');\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n    busyPushingNext = true;\n    operation(...args);\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedSubject extends Subject {\n  _orderedNext = orderedQueueOperation(value => super.next(value));\n  next(value) {\n    this._orderedNext(value);\n  }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedBehaviorSubject extends BehaviorSubject {\n  _orderedNext = orderedQueueOperation(value => super.next(value));\n  _currentValue;\n  constructor(value) {\n    super(value);\n    this._currentValue = value;\n  }\n  getValue() {\n    return this._currentValue;\n  }\n  next(value) {\n    this._currentValue = value;\n    this._orderedNext(value);\n  }\n}\nfunction ɵwrapObserverCalls(invokeFn) {\n  return source => {\n    return new Observable(subscriber => {\n      return source.subscribe({\n        next(value) {\n          invokeFn(() => subscriber.next(value));\n        },\n        error(error) {\n          invokeFn(() => subscriber.error(error));\n        },\n        complete() {\n          invokeFn(() => subscriber.complete());\n        }\n      });\n    });\n  };\n}\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass ɵStateStream extends ɵOrderedBehaviorSubject {\n  state = toSignal(this.pipe(ɵwrapObserverCalls(untracked)), {\n    manualCleanup: true,\n    requireSync: true\n  });\n  constructor() {\n    super({});\n    // Complete the subject once the root injector is destroyed to ensure\n    // there are no active subscribers that would receive events or perform\n    // any actions after the application is destroyed.\n    // The `StateStream` should never emit values once the root view is removed,\n    // such as when the `ApplicationRef.destroy()` method is called. This is crucial\n    // for preventing memory leaks in server-side rendered apps, where a new `StateStream`\n    // is created for each HTTP request. If users forget to unsubscribe from `store.select`\n    // or `store.subscribe`, it can result in significant memory leaks in SSR apps.\n    inject(DestroyRef).onDestroy(() => this.complete());\n  }\n  /** @nocollapse */\n  static ɵfac = function ɵStateStream_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵStateStream)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵStateStream,\n    factory: ɵStateStream.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵStateStream, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass ɵNgxsActionRegistry {\n  // Instead of going over the states list every time an action is dispatched,\n  // we are constructing a map of action types to lists of action metadata.\n  // If the `@@Init` action is handled in two different states, the action\n  // metadata list will contain two objects that have the state `instance` and\n  // method names to be used as action handlers (decorated with `@Action(InitState)`).\n  _actionTypeToHandlersMap = new Map();\n  constructor() {\n    inject(DestroyRef).onDestroy(() => this._actionTypeToHandlersMap.clear());\n  }\n  get(type) {\n    return this._actionTypeToHandlersMap.get(type);\n  }\n  register(type, handler) {\n    const handlers = this._actionTypeToHandlersMap.get(type) ?? new Set();\n    handlers.add(handler);\n    this._actionTypeToHandlersMap.set(type, handlers);\n    return () => {\n      const handlers = this._actionTypeToHandlersMap.get(type);\n      handlers.delete(handler);\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function ɵNgxsActionRegistry_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵNgxsActionRegistry)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵNgxsActionRegistry,\n    factory: ɵNgxsActionRegistry.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵNgxsActionRegistry, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { StateToken, ɵINITIAL_STATE_TOKEN, ɵInitialState, ɵMETA_KEY, ɵMETA_OPTIONS_KEY, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, ɵNgxsActionRegistry, ɵNgxsAppBootstrappedState, ɵOrderedBehaviorSubject, ɵOrderedSubject, ɵSELECTOR_META_KEY, ɵStateStream, ɵdefineProperty, ɵensureSelectorMetadata, ɵensureStoreMetadata, ɵgetSelectorMetadata, ɵgetStoreMetadata, ɵhasOwnProperty, ɵmemoize, ɵwrapObserverCalls };\n", "import { InjectionToken } from '@angular/core';\n\n/**\n * Init action\n */\nclass InitState {\n    static type = '@@INIT';\n}\n/**\n * Update action\n */\nclass UpdateState {\n    addedStates;\n    static type = '@@UPDATE_STATE';\n    constructor(addedStates) {\n        this.addedStates = addedStates;\n    }\n}\n\n/**\n * A multi-provider token used to resolve to custom NGXS plugins provided\n * at the root and feature levels through the `{provide}` scheme.\n *\n * @deprecated from v18.0.0, use `withNgxsPlugin` instead.\n */\nconst NGXS_PLUGINS = /* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_PLUGINS' : '');\nfunction ɵisPluginClass(plugin) {\n    // Determines whether the provided value is a class rather than a function.\n    // If it’s a class, its handle method should be defined on its prototype,\n    // as plugins can be either classes or functions.\n    return !!plugin.prototype.handle;\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n    return action.constructor?.type || action.type;\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n    const type1 = getActionTypeFromInstance(action1);\n    return function (action2) {\n        return type1 === getActionTypeFromInstance(action2);\n    };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n    obj = { ...obj };\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part] };\n        }\n        return acc?.[part];\n    }, obj);\n    return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc?.[part], obj);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue, ɵisPluginClass };\n\n", "const isArray = Array.isArray;\nconst isFunction = (value) => typeof value == 'function';\nconst isStateOperator = isFunction;\nconst isPredicate = isFunction;\nconst isNumber = (value) => typeof value === 'number';\nconst invalidIndex = (index) => Number.isNaN(index) || index === -1;\n\n/**\n * @param items - Specific items to append to the end of an array\n */\nfunction append(items) {\n    return function appendOperator(existing) {\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n        // just return `existing`\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n        if (itemsNotProvidedButExistingIs) {\n            return existing;\n        }\n        if (isArray(existing)) {\n            return existing.concat(items);\n        }\n        // For example if some property is added dynamically\n        // and didn't exist before thus it's not `ArrayLike`\n        return items;\n    };\n}\n\nfunction compose(...operators) {\n    return function composeOperator(existing) {\n        return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n    };\n}\n\nfunction retrieveValue(operatorOrValue, existing) {\n    // If state operator is a function\n    // then call it with an original value\n    if (isStateOperator(operatorOrValue)) {\n        const value = operatorOrValue(existing);\n        return value;\n    }\n    // If operator or value was not provided\n    // e.g. `elseOperatorOrValue` is `undefined`\n    // then we just return an original value\n    if (operatorOrValue === undefined) {\n        return existing;\n    }\n    return operatorOrValue;\n}\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n    return function iifOperator(existing) {\n        // Convert the value to a boolean\n        let result = !!condition;\n        // but if it is a function then run it to get the result\n        if (isPredicate(condition)) {\n            result = condition(existing);\n        }\n        if (result) {\n            return retrieveValue(trueOperatorOrValue, existing);\n        }\n        return retrieveValue(elseOperatorOrValue, existing);\n    };\n}\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nfunction insertItem(value, beforePosition) {\n    return function insertItemOperator(existing) {\n        // Have to check explicitly for `null` and `undefined`\n        // because `value` can be `0`, thus `!value` will return `true`\n        if (value == null && existing) {\n            return existing;\n        }\n        // Property may be dynamic and might not existed before\n        if (!isArray(existing)) {\n            return [value];\n        }\n        const clone = existing.slice();\n        let index = 0;\n        // No need to call `isNumber`\n        // as we are checking `> 0` not `>= 0`\n        // everything except number will return false here\n        if (beforePosition > 0) {\n            index = beforePosition;\n        }\n        clone.splice(index, 0, value);\n        return clone;\n    };\n}\n\nfunction patch(patchObject) {\n    return function patchStateOperator(existing) {\n        let clone = null;\n        for (const k in patchObject) {\n            const newValue = patchObject[k];\n            const existingPropValue = existing?.[k];\n            const newPropValue = isStateOperator(newValue)\n                ? newValue(existingPropValue)\n                : newValue;\n            if (newPropValue !== existingPropValue) {\n                if (!clone) {\n                    clone = { ...existing };\n                }\n                clone[k] = newPropValue;\n            }\n        }\n        return clone || existing;\n    };\n}\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nfunction updateItem(selector, operatorOrValue) {\n    return function updateItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        let value = null;\n        // Need to check if the new item value will change the existing item value\n        // then, only if it will change it then clone the array and set the item\n        const theOperatorOrValue = operatorOrValue;\n        if (isStateOperator(theOperatorOrValue)) {\n            value = theOperatorOrValue(existing[index]);\n        }\n        else {\n            value = theOperatorOrValue;\n        }\n        // If the value hasn't been mutated\n        // then we just return `existing` array\n        if (value === existing[index]) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone[index] = value;\n        return clone;\n    };\n}\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nfunction removeItem(selector) {\n    return function removeItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone.splice(index, 1);\n        return clone;\n    };\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { append, compose, iif, insertItem, isPredicate, isStateOperator, patch, removeItem, updateItem };\n\n", "import * as i0 from '@angular/core';\nimport { inject, Injectable, DestroyRef, NgZone, Injector, runInInjectionContext, InjectionToken, ErrorHandler, ɵisPromise as _isPromise, computed, makeEnvironmentProviders, provideEnvironmentInitializer, NgModule, APP_BOOTSTRAP_LISTENER, ApplicationRef, PendingTasks, assertInInjectionContext, EnvironmentInjector, createEnvironmentInjector } from '@angular/core';\nimport { config, Observable, Subject, of, forkJoin, map, shareReplay, filter, take, mergeMap, EMPTY, from, isObservable, defaultIfEmpty, takeUntil, finalize, catchError, distinctUntilChanged, startWith, skip, buffer, debounceTime } from 'rxjs';\nimport { ɵwrapObserverCalls as _wrapObserverCalls, ɵOrderedSubject as _OrderedSubject, ɵStateStream as _StateStream, ɵhasOwnProperty as _hasOwnProperty, ɵmemoize as _memoize, ɵgetStoreMetadata as _getStoreMetadata, ɵgetSelectorMetadata as _getSelectorMetadata, ɵMETA_KEY as _META_KEY, ɵINITIAL_STATE_TOKEN as _INITIAL_STATE_TOKEN, ɵNgxsActionRegistry as _NgxsActionRegistry, ɵNgxsAppBootstrappedState as _NgxsAppBootstrappedState, ɵensureStoreMetadata as _ensureStoreMetadata, ɵMETA_OPTIONS_KEY as _META_OPTIONS_KEY, ɵensureSelectorMetadata as _ensureSelectorMetadata, ɵNGXS_STATE_CONTEXT_FACTORY as _NGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY as _NGXS_STATE_FACTORY } from '@ngxs/store/internals';\nexport { StateToken } from '@ngxs/store/internals';\nimport { NGXS_PLUGINS, getActionTypeFromInstance, InitState, UpdateState, setValue, getValue, ɵisPluginClass as _isPluginClass } from '@ngxs/store/plugins';\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';\nimport { isStateOperator } from '@ngxs/store/operators';\nclass PluginManager {\n  plugins = [];\n  _parentManager = inject(PluginManager, {\n    optional: true,\n    skipSelf: true\n  });\n  _pluginHandlers = inject(NGXS_PLUGINS, {\n    optional: true\n  });\n  constructor() {\n    this.registerHandlers();\n  }\n  get _rootPlugins() {\n    return this._parentManager?.plugins || this.plugins;\n  }\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this._rootPlugins.push(...pluginHandlers);\n  }\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n  /** @nocollapse */\n  static ɵfac = function PluginManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || PluginManager)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PluginManager,\n    factory: PluginManager.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return _wrapObserverCalls(fn => ngxsExecutionStrategy.leave(fn));\n}\nconst ɵɵunhandledRxjsErrorCallbacks = new WeakMap();\nlet installed = false;\nfunction installOnUnhandhedErrorHandler() {\n  if (installed) {\n    return;\n  }\n  const existingHandler = config.onUnhandledError;\n  config.onUnhandledError = function (error) {\n    const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n    if (unhandledErrorCallback) {\n      unhandledErrorCallback();\n    } else if (existingHandler) {\n      existingHandler.call(this, error);\n    } else {\n      throw error;\n    }\n  };\n  installed = true;\n}\nfunction executeUnhandledCallback(error) {\n  const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n  if (unhandledErrorCallback) {\n    unhandledErrorCallback();\n    return true;\n  }\n  return false;\n}\nfunction assignUnhandledCallback(error, callback) {\n  // Since the error can be essentially anything, we must ensure that we only\n  // handle objects, as weak maps do not allow any other key type besides objects.\n  // The error can also be a string if thrown in the following manner: `throwError('My Error')`.\n  if (error && typeof error === 'object') {\n    let hasBeenCalled = false;\n    ɵɵunhandledRxjsErrorCallbacks.set(error, () => {\n      if (!hasBeenCalled) {\n        hasBeenCalled = true;\n        callback();\n      }\n    });\n  }\n  return error;\n}\nfunction fallbackSubscriber(ngZone) {\n  return source => {\n    let subscription = source.subscribe({\n      error: error => {\n        ngZone.runOutsideAngular(() => {\n          // This is necessary to schedule a microtask to ensure that synchronous\n          // errors are not reported before the real subscriber arrives. If an error\n          // is thrown synchronously in any action, it will be reported to the error\n          // handler regardless. Since RxJS reports unhandled errors asynchronously,\n          // implementing a microtask ensures that we are also safe in this scenario.\n          queueMicrotask(() => {\n            if (subscription) {\n              executeUnhandledCallback(error);\n            }\n          });\n        });\n      }\n    });\n    return new Observable(subscriber => {\n      // Now that there is a real subscriber, we can unsubscribe our pro-active subscription\n      subscription?.unsubscribe();\n      subscription = null;\n      return source.subscribe(subscriber);\n    });\n  };\n}\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n  constructor() {\n    super();\n    // Complete the subject once the root injector is destroyed to ensure\n    // there are no active subscribers that would receive events or perform\n    // any actions after the application is destroyed.\n    inject(DestroyRef).onDestroy(() => this.complete());\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalDispatchedActionResults_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalDispatchedActionResults)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalDispatchedActionResults,\n    factory: InternalDispatchedActionResults.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass InternalNgxsExecutionStrategy {\n  _ngZone = inject(NgZone);\n  enter(func) {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return this._runInsideAngular(func);\n    }\n    return this._runOutsideAngular(func);\n  }\n  leave(func) {\n    return this._runInsideAngular(func);\n  }\n  _runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n  _runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalNgxsExecutionStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalNgxsExecutionStrategy)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalNgxsExecutionStrategy,\n    factory: InternalNgxsExecutionStrategy.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * Status of a dispatched action\n */\nvar ActionStatus;\n(function (ActionStatus) {\n  ActionStatus[\"Dispatched\"] = \"DISPATCHED\";\n  ActionStatus[\"Successful\"] = \"SUCCESSFUL\";\n  ActionStatus[\"Canceled\"] = \"CANCELED\";\n  ActionStatus[\"Errored\"] = \"ERRORED\";\n})(ActionStatus || (ActionStatus = {}));\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends _OrderedSubject {\n  // This subject will be the first to know about the dispatched action, its purpose is for\n  // any logic that must be executed before action handlers are invoked (i.e., cancelation).\n  dispatched$ = new Subject();\n  constructor() {\n    super();\n    this.subscribe(ctx => {\n      if (ctx.status === ActionStatus.Dispatched) {\n        this.dispatched$.next(ctx);\n      }\n    });\n    const destroyRef = inject(DestroyRef);\n    destroyRef.onDestroy(() => {\n      // Complete the subject once the root injector is destroyed to ensure\n      // there are no active subscribers that would receive events or perform\n      // any actions after the application is destroyed.\n      this.complete();\n      this.dispatched$.complete();\n    });\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalActions_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalActions)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalActions,\n    factory: InternalActions.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n  constructor() {\n    const internalActions$ = inject(InternalActions);\n    const internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n    // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The shared `Subject` reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    const sharedInternalActions$ = new Subject();\n    internalActions$.pipe(leaveNgxs(internalExecutionStrategy)).subscribe(sharedInternalActions$);\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n  /** @nocollapse */\n  static ɵfac = function Actions_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || Actions)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Actions,\n    factory: Actions.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass InternalDispatcher {\n  _ngZone = inject(NgZone);\n  _actions = inject(InternalActions);\n  _actionResults = inject(InternalDispatchedActionResults);\n  _pluginManager = inject(PluginManager);\n  _stateStream = inject(_StateStream);\n  _ngxsExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n  _injector = inject(Injector);\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n    return result.pipe(fallbackSubscriber(this._ngZone), leaveNgxs(this._ngxsExecutionStrategy));\n  }\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(undefined);\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action))).pipe(map(() => undefined));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n  dispatchSingle(action) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return new Observable(subscriber => subscriber.error(error));\n      }\n    }\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n    return compose(this._injector, [...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n      this._actions.next({\n        action: nextAction,\n        status: ActionStatus.Dispatched\n      });\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== ActionStatus.Dispatched), take(1), shareReplay());\n  }\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(mergeMap(ctx => {\n      switch (ctx.status) {\n        case ActionStatus.Successful:\n          // The `createDispatchObservable` function should return the\n          // state, as its result is used by plugins.\n          return of(this._stateStream.getValue());\n        case ActionStatus.Errored:\n          throw ctx.error;\n        default:\n          // Once dispatched or canceled, we complete it immediately because\n          // `dispatch()` should emit (or error, or complete) as soon as it succeeds or fails.\n          return EMPTY;\n      }\n    }), shareReplay());\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalDispatcher_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalDispatcher)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalDispatcher,\n    factory: InternalDispatcher.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n */\nconst compose = (injector, funcs) => (...args) => {\n  const curr = funcs.shift();\n  return runInInjectionContext(injector, () => curr(...args, (...nextArgs) => compose(injector, funcs)(...nextArgs)));\n};\n\n// The injection token is used to resolve a list of states provided at\n// the root level through either `NgxsModule.forRoot` or `provideStore`.\nconst ROOT_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROOT_STATE_TOKEN' : '');\n// The injection token is used to resolve a list of states provided at\n// the feature level through either `NgxsModule.forFeature` or `provideStates`.\n// The Array<Array> is used to overload the resolved value of the token because\n// it is a multi-provider token.\nconst FEATURE_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FEATURE_STATE_TOKEN' : '');\n// The injection token is used to resolve to options provided at the root\n// level through either `NgxsModule.forRoot` or `provideStore`.\nconst NGXS_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_OPTIONS' : '');\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n  /**\n   * Run in development mode. This will add additional debugging features:\n   * - Object.freeze on the state and actions to guarantee immutability\n   * (default: false)\n   *\n   * Note: this property will be accounted only in development mode.\n   * It makes sense to use it only during development to ensure there're no state mutations.\n   * When building for production, the `Object.freeze` will be tree-shaken away.\n   */\n  developmentMode;\n  compatibility = {\n    strictContentSecurityPolicy: false\n  };\n  /**\n   * Defining shared selector options\n   */\n  selectorOptions = {\n    injectContainerState: false,\n    suppressErrors: false\n  };\n  /** @nocollapse */\n  static ɵfac = function NgxsConfig_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsConfig)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsConfig,\n    factory: () => (() => {\n      const defaultConfig = new NgxsConfig();\n      const config = inject(NGXS_OPTIONS);\n      return {\n        ...defaultConfig,\n        ...config,\n        selectorOptions: {\n          ...defaultConfig.selectorOptions,\n          ...config.selectorOptions\n        }\n      };\n    })(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => {\n        const defaultConfig = new NgxsConfig();\n        const config = inject(NGXS_OPTIONS);\n        return {\n          ...defaultConfig,\n          ...config,\n          selectorOptions: {\n            ...defaultConfig.selectorOptions,\n            ...config.selectorOptions\n          }\n        };\n      }\n    }]\n  }], null, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  previousValue;\n  currentValue;\n  firstChange;\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (_hasOwnProperty(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * @ignore\n */\nclass InternalStateOperations {\n  _stateStream = inject(_StateStream);\n  _dispatcher = inject(InternalDispatcher);\n  _config = inject(NgxsConfig);\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations();\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState({\n      ...currentState,\n      ...results.defaults\n    });\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalStateOperations_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalStateOperations)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalStateOperations,\n    factory: InternalStateOperations.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    const {\n      suppressErrors\n    } = selectorOptions;\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // If the lambda attempts to access something in the state that doesn't exist,\n      // it will throw a `TypeError`. Since this behavior is common, we simply return\n      // `undefined` in such cases.\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (suppressErrors && ex instanceof TypeError) {\n          return undefined;\n        }\n        // We're logging an error in this function because it may be used by `select`,\n        // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch\n        // exceptions there to log errors.\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n          const message = 'The selector below has thrown an error upon invocation. ' + 'Please check for any unsafe property access that may result in null ' + 'or undefined values.';\n          // Avoid concatenating the message with the original function, as this will\n          // invoke `toString()` on the function. Instead, log it as the second argument.\n          // This way, developers will be able to navigate to the actual code in the browser.\n          console.error(message, selectorMetaData.originalFn);\n        }\n        throw ex;\n      }\n    };\n  };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata?.containerClass;\n  const wrappedFn = function wrappedSelectorFn() {\n    // eslint-disable-next-line prefer-rest-params\n    const returnValue = originalFn.apply(containerClass, arguments);\n    if (typeof returnValue === 'function') {\n      const innerMemoizedFn = _memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = _memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  // The container state refers to the state class that includes the\n  // definition of the selector function, for example:\n  // @State()\n  // class AnimalsState {\n  //   @Selector()\n  //   static getAnimals(state: AnimalsStateModel) {}\n  // }\n  // The `AnimalsState` serves as the container state. Additionally, the\n  // selector may reside within a namespace or another class lacking the\n  // `@State` decorator, thus not being treated as the container state.\n  const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = _getStoreMetadata(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  selectorsToApply.push(...selectors);\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n  return metadata?.makeRootSelector || (() => selector);\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  return obj => {\n    for (let i = 0; i < paths.length; i++) {\n      if (!obj) return undefined;\n      obj = obj[paths[i]];\n    }\n    return obj;\n  };\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\nconst ɵPROP_GETTER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PROP_GETTER' : '', {\n  providedIn: 'root',\n  factory: () => inject(NgxsConfig).compatibility?.strictContentSecurityPolicy ? compliantPropGetter : fastPropGetter\n});\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  // Resolve a state's name from the class reference.\n  const findName = stateClass => {\n    const meta = stateClasses.find(s => s === stateClass);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[_META_KEY].name;\n  };\n  // Build the dependency graph.\n  return stateClasses.reduce((graph, stateClass) => {\n    const meta = stateClass[_META_KEY];\n    graph[meta.name] = (meta.children || []).map(findName);\n    return graph;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[_META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, out = {}) {\n  // Recursively find the full dotted parent path for a given key.\n  const find = (graph, target) => {\n    for (const key in graph) {\n      if (graph[key]?.includes(target)) {\n        const parent = find(graph, key);\n        return parent ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  // Build full path for each key\n  for (const key in obj) {\n    const parent = find(obj, key);\n    out[key] = parent ? `${parent}.${key}` : key;\n  }\n  return out;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  // DFS (Depth-First Search) to visit each node and its dependencies.\n  const visit = (name, ancestors = []) => {\n    visited[name] = true;\n    ancestors.push(name);\n    for (const dep of graph[name]) {\n      if (typeof ngDevMode !== 'undefined' && ngDevMode && ancestors.includes(dep)) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (!visited[dep]) visit(dep, ancestors.slice());\n    }\n    // Add to sorted list if not already included.\n    if (!sorted.includes(name)) sorted.push(name);\n  };\n  // Start DFS from each key\n  for (const key in graph) visit(key);\n  return sorted.reverse();\n}\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getUndecoratedStateWithInjectableWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction getInvalidInitializationOrderMessage(addedStates) {\n  let message = 'You have an invalid state initialization order. This typically occurs when `NgxsModule.forFeature`\\n' + 'or `provideStates` is called before `NgxsModule.forRoot` or `provideStore`.\\n' + 'One example is when `NgxsRouterPluginModule.forRoot` is called before `NgxsModule.forRoot`.';\n  if (addedStates) {\n    const stateNames = Object.keys(addedStates).map(stateName => `\"${stateName}\"`);\n    message += '\\nFeature states added before the store initialization is complete: ' + `${stateNames.join(', ')}.`;\n  }\n  return message;\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nconst stateNameRegex = /* @__PURE__ */new RegExp('^[a-zA-Z0-9_]+$');\nfunction ensureStateNameIsValid(name) {\n  if (!name) {\n    throwStateNamePropertyError();\n  } else if (!stateNameRegex.test(name)) {\n    throwStateNameError(name);\n  }\n}\nfunction ensureStateNameIsUnique(stateName, state, statesByName) {\n  const existingState = statesByName[stateName];\n  if (existingState && existingState !== state) {\n    throwStateUniqueError(stateName, state.name, existingState.name);\n  }\n}\nfunction ensureStatesAreDecorated(stateClasses) {\n  stateClasses.forEach(stateClass => {\n    if (!_getStoreMetadata(stateClass)) {\n      throwStateDecoratorError(stateClass.name);\n    }\n  });\n}\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n    return;\n  }\n  console.warn(getUndecoratedStateWithInjectableWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n  // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n  const annotations = stateClass.__annotations__ || [];\n  return annotations.some(annotation => annotation?.ngMetadataName === 'Injectable');\n}\nconst NGXS_DEVELOPMENT_OPTIONS = /* @__PURE__ */new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_DEVELOPMENT_OPTIONS' : '', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nclass NgxsUnhandledActionsLogger {\n  /**\n   * These actions should be ignored by default; the user can increase this\n   * list in the future via the `ignoreActions` method.\n   */\n  _ignoredActions = new Set([InitState.type, UpdateState.type]);\n  constructor() {\n    const options = inject(NGXS_DEVELOPMENT_OPTIONS);\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n    if (actionShouldBeIgnored) {\n      return;\n    }\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsUnhandledActionsLogger_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsUnhandledActionsLogger)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsUnhandledActionsLogger,\n    factory: NgxsUnhandledActionsLogger.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], () => [], null);\n})();\nclass NgxsUnhandledErrorHandler {\n  _ngZone = inject(NgZone);\n  _errorHandler = inject(ErrorHandler);\n  /**\n   * The `_unhandledErrorContext` is left unused internally since we do not\n   * require it for internal operations. However, developers who wish to provide\n   * their own custom error handler may utilize this context information.\n   */\n  handleError(error, _unhandledErrorContext) {\n    // In order to avoid duplicate error handling, it is necessary to leave\n    // the Angular zone to ensure that errors are not caught twice. The `handleError`\n    // method may contain a `throw error` statement, which is used to re-throw the error.\n    // If the error is re-thrown within the Angular zone, it will be caught again by the\n    // Angular zone. By default, `@angular/core` leaves the Angular zone when invoking\n    // `handleError` (see `_callAndReportToErrorHandler`).\n    this._ngZone.runOutsideAngular(() => this._errorHandler.handleError(error));\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsUnhandledErrorHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsUnhandledErrorHandler)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsUnhandledErrorHandler,\n    factory: NgxsUnhandledErrorHandler.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledErrorHandler, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Dispatched]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Successful]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Canceled]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [ActionStatus.Successful, ActionStatus.Canceled, ActionStatus.Errored];\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Errored], mapActionResult);\n}\nfunction ofActionOperator(allowedTypes, statuses,\n// This could have been written as\n// `OperatorFunction<ActionContext, ActionCompletion | any>`, as it maps\n// either to `ctx.action` or to `ActionCompletion`. However,\n// `ActionCompletion | any` defaults to `any`, rendering the union\n// type meaningless.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: ActionStatus.Successful === status,\n        canceled: ActionStatus.Canceled === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = {\n      ...existingState\n    };\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n  _internalStateOperations = inject(InternalStateOperations);\n  /**\n   * Create the state context\n   */\n  createStateContext(path) {\n    const root = this._internalStateOperations.getRootStateOperations();\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState, path);\n      },\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        setStateFromOperator(root, currentAppState, patchOperator, path);\n      },\n      setState(val) {\n        const currentAppState = root.getState();\n        if (isStateOperator(val)) {\n          setStateFromOperator(root, currentAppState, val, path);\n        } else {\n          setStateValue(root, currentAppState, val, path);\n        }\n      },\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function StateContextFactory_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || StateContextFactory)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateContextFactory,\n    factory: StateContextFactory.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction setStateValue(root, currentAppState, newValue, path) {\n  const newAppState = setValue(currentAppState, path, newValue);\n  root.setState(newAppState);\n  return newAppState;\n  // In doing this refactoring I noticed that there is a 'bug' where the\n  // application state is returned instead of this state slice.\n  // This has worked this way since the beginning see:\n  // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n  // This needs to be fixed, but is a 'breaking' change.\n  // I will do this fix in a subsequent PR and we can decide how to handle it.\n}\nfunction setStateFromOperator(root, currentAppState, stateOperator, path) {\n  const local = getState(currentAppState, path);\n  const newValue = stateOperator(local);\n  return setStateValue(root, currentAppState, newValue, path);\n}\nfunction getState(currentAppState, path) {\n  return getValue(currentAppState, path);\n}\nclass InternalActionHandlerFactory {\n  _actions = inject(InternalActions);\n  _stateContextFactory = inject(StateContextFactory);\n  createActionHandler(path, handlerFn, options) {\n    const {\n      dispatched$\n    } = this._actions;\n    return action => {\n      const stateContext = this._stateContextFactory.createStateContext(path);\n      let result = handlerFn(stateContext, action);\n      // We need to use `isPromise` instead of checking whether\n      // `result instanceof Promise`. In zone.js patched environments, `global.Promise`\n      // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js\n      // for certain reasons, might not work with `instanceof`. For instance, the dynamic\n      // import returns a native promise (not a `ZoneAwarePromise`), causing this check to\n      // be falsy.\n      if (_isPromise(result)) {\n        result = from(result);\n      }\n      if (isObservable(result)) {\n        result = result.pipe(mergeMap(value => _isPromise(value) || isObservable(value) ? value : of(value)),\n        // If this observable has completed without emitting any values,\n        // we wouldn't want to complete the entire chain of actions.\n        // If any observable completes, then the action will be canceled.\n        // For instance, if any action handler had a statement like\n        // `handler(ctx) { return EMPTY; }`, then the action would be canceled.\n        // See https://github.com/ngxs/store/issues/1568\n        // Note that we actually don't care about the return type; we only care\n        // about emission, and thus `undefined` is applicable by the framework.\n        defaultIfEmpty(undefined));\n        if (options.cancelUncompleted) {\n          const canceled = dispatched$.pipe(ofActionDispatched(action));\n          result = result.pipe(takeUntil(canceled));\n        }\n        result = result.pipe(\n        // Note that we use the `finalize` operator only when the action handler\n        // explicitly returns an observable (or a promise) to wait for. This means\n        // the action handler is written in a \"fire & wait\" style. If the handler’s\n        // result is unsubscribed (either because the observable has completed or\n        // it was unsubscribed by `takeUntil` due to a new action being dispatched),\n        // we prevent writing to the state context.\n        finalize(() => {\n          if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            function noopAndWarn() {\n              console.warn(`\"${action}\" attempted to change the state, but the change was ignored because state updates are not allowed after the action handler has completed.`);\n            }\n            stateContext.setState = noopAndWarn;\n            stateContext.patchState = noopAndWarn;\n          } else {\n            stateContext.setState = noop;\n            stateContext.patchState = noop;\n          }\n        }));\n      } else {\n        // If the action handler is synchronous and returns nothing (`void`), we\n        // still have to convert the result to a synchronous observable.\n        result = of(undefined);\n      }\n      return result;\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function InternalActionHandlerFactory_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InternalActionHandlerFactory)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalActionHandlerFactory,\n    factory: InternalActionHandlerFactory.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActionHandlerFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n// This is used to replace `setState` and `patchState` once the action\n// handler has been unsubscribed or completed, to prevent writing\n// to the state context.\nfunction noop() {}\nfunction cloneDefaults(defaults) {\n  let value = defaults === undefined ? {} : defaults;\n  if (defaults) {\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (typeof defaults === 'object') {\n      value = {\n        ...defaults\n      };\n    }\n  }\n  return value;\n}\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n *\n * Root and feature initializers call `addAndReturnDefaults()` to add those states\n * to the global graph. Since `addAndReturnDefaults` runs within the injection\n * context (which might be the root injector or a feature injector), we can\n * retrieve an instance of the state class using `inject(StateClass)`.\n * @ignore\n */\nclass StateFactory {\n  _injector = inject(Injector);\n  _config = inject(NgxsConfig);\n  _actionHandlerFactory = inject(InternalActionHandlerFactory);\n  _actions = inject(InternalActions);\n  _actionResults = inject(InternalDispatchedActionResults);\n  _initialState = inject(_INITIAL_STATE_TOKEN, {\n    optional: true\n  });\n  _actionRegistry = inject(_NgxsActionRegistry);\n  _propGetter = inject(ɵPROP_GETTER);\n  _actionsSubscription = null;\n  _ngxsUnhandledErrorHandler = null;\n  _states = [];\n  _statesByName = {};\n  _statePaths = {};\n  getRuntimeSelectorContext = _memoize(() => {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const stateFactory = this;\n    const propGetter = stateFactory._propGetter;\n    function resolveGetter(key) {\n      const path = stateFactory._statePaths[key];\n      return path ? propGetter(path.split('.')) : null;\n    }\n    const context = {\n      getStateGetter(key) {\n        // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.\n        // This is a Terser annotation, which will function only in the production mode.\n        let getter = /*@__INLINE__*/resolveGetter(key);\n        if (getter) {\n          return getter;\n        }\n        return (...args) => {\n          // Late loaded getter\n          if (!getter) {\n            getter = /*@__INLINE__*/resolveGetter(key);\n          }\n          return getter ? getter(...args) : undefined;\n        };\n      },\n      getSelectorOptions(localOptions) {\n        const globalSelectorOptions = stateFactory._config.selectorOptions;\n        return {\n          ...globalSelectorOptions,\n          ...(localOptions || {})\n        };\n      }\n    };\n    return context;\n  });\n  constructor() {\n    inject(DestroyRef).onDestroy(() => this._actionsSubscription?.unsubscribe());\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      ensureStatesAreDecorated(stateClasses);\n    }\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[_META_KEY];\n      this.addRuntimeInfoToMeta(meta, path);\n      if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: inject(stateClass),\n        defaults: cloneDefaults(meta.defaults)\n      };\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n      this._states.push(stateMap);\n      this.hydrateActionMetasMap(stateMap);\n    }\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n  connectActionHandlers() {\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === ActionStatus.Dispatched), mergeMap(ctx => {\n      const action = ctx.action;\n      return this.invokeActions(action).pipe(map(() => ({\n        action,\n        status: ActionStatus.Successful\n      })), defaultIfEmpty({\n        action,\n        status: ActionStatus.Canceled\n      }), catchError(error => {\n        const ngxsUnhandledErrorHandler = this._ngxsUnhandledErrorHandler ||= this._injector.get(NgxsUnhandledErrorHandler);\n        const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, {\n          action\n        }));\n        return of({\n          action,\n          status: ActionStatus.Errored,\n          error: handleableError\n        });\n      }));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(action) {\n    const type = getActionTypeFromInstance(action);\n    const results = [];\n    // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n    let actionHasBeenHandled = false;\n    const actionHandlers = this._actionRegistry.get(type);\n    if (actionHandlers) {\n      for (const actionHandler of actionHandlers) {\n        let result;\n        try {\n          result = actionHandler(action);\n        } catch (e) {\n          result = new Observable(subscriber => subscriber.error(e));\n        }\n        results.push(result);\n        actionHasBeenHandled = true;\n      }\n    }\n    // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n      // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n      unhandledActionsLogger?.warn(action);\n    }\n    if (!results.length) {\n      results.push(of(undefined));\n    }\n    return forkJoin(results);\n  }\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this._statesByName;\n    for (const stateClass of stateClasses) {\n      const stateName = _getStoreMetadata(stateClass).name;\n      if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n    return {\n      newStates\n    };\n  }\n  addRuntimeInfoToMeta(meta, path) {\n    this._statePaths[meta.name] = path;\n    // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins\n    meta.path = path;\n  }\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n    // This checks whether a state has been already added to the global graph and\n    // its lifecycle is in 'bootstrapped' state.\n    return this._statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n  hydrateActionMetasMap({\n    path,\n    actions,\n    instance\n  }) {\n    for (const actionType of Object.keys(actions)) {\n      const actionHandlers = actions[actionType].map(actionMeta => {\n        const handlerFn = (ctx, action) => instance[actionMeta.fn](ctx, action);\n        return this._actionHandlerFactory.createActionHandler(path, handlerFn, actionMeta.options);\n      });\n      for (const actionHandler of actionHandlers) {\n        this._actionRegistry.register(actionType, actionHandler);\n      }\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function StateFactory_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || StateFactory)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateFactory,\n    factory: StateFactory.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nclass Store {\n  _stateStream = inject(_StateStream);\n  _internalStateOperations = inject(InternalStateOperations);\n  _config = inject(NgxsConfig);\n  _internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n  _stateFactory = inject(StateFactory);\n  /**\n   * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n   * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n   * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n   */\n  _selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n  constructor() {\n    this.initStateStream();\n  }\n  /**\n   * Dispatches action(s).\n   */\n  dispatch(actionOrActions) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (\n      // If a single action is dispatched and it's nullable.\n      actionOrActions == null ||\n      // If a list of actions is dispatched and any of the actions are nullable.\n      Array.isArray(actionOrActions) && actionOrActions.some(action => action == null)) {\n        const error = new Error('`dispatch()` was called without providing an action.');\n        return new Observable(subscriber => subscriber.error(error));\n      }\n    }\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n  /**\n   * Selects a slice of data from the store.\n   */\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map(selectorFn), catchError(error => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {\n        return of(undefined);\n      }\n      // rethrow other errors\n      throw error;\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n  /**\n   * Select one slice of data from the store.\n   */\n  selectOnce(selector) {\n    return this.select(selector).pipe(take(1));\n  }\n  /**\n   * Select a snapshot from the state.\n   */\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Select a signal from the state.\n   */\n  selectSignal(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return computed(() => selectorFn(this._stateStream.state()));\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state) {\n    this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n  initStateStream() {\n    const initialStateValue = inject(_INITIAL_STATE_TOKEN);\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      this._stateStream.next(initialStateValue);\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function Store_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || Store)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Store,\n    factory: Store.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * InjectionToken that registers preboot functions (called before the root initializer).\n */\nconst NGXS_PREBOOT_FNS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_PREBOOT_FNS' : '');\n/**\n * This function registers a preboot function which will be called before the root\n * store initializer is run, but after all of the NGXS features are provided and\n * available for injection. This is useful for registering action stream listeners\n * before any action is dispatched.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPreboot(() => {\n *         const actions$ = inject(Actions);\n *         actions$.subscribe(ctx => console.log(ctx));\n *       })\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPreboot(prebootFn) {\n  return makeEnvironmentProviders([{\n    provide: NGXS_PREBOOT_FNS,\n    multi: true,\n    useValue: prebootFn\n  }]);\n}\nconst ROOT_STORE_GUARD = /* @__PURE__ */new InjectionToken('ROOT_STORE_GUARD', {\n  providedIn: 'root',\n  factory: () => ({\n    initialized: false\n  })\n});\nfunction assertRootStoreNotInitialized() {\n  const rootStoreGuard = inject(ROOT_STORE_GUARD);\n  if (rootStoreGuard.initialized) {\n    throw new Error('provideStore() should only be called once.');\n  }\n  rootStoreGuard.initialized = true;\n}\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n  static store = null;\n  static config = null;\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n    inject(DestroyRef).onDestroy(() => {\n      SelectFactory.store = null;\n      SelectFactory.config = null;\n    });\n  }\n  /** @nocollapse */\n  static ɵfac = function SelectFactory_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectFactory,\n    factory: SelectFactory.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: Store\n  }, {\n    type: NgxsConfig\n  }], null);\n})();\nclass LifecycleStateManager {\n  _store = inject(Store);\n  _internalStateOperations = inject(InternalStateOperations);\n  _stateContextFactory = inject(StateContextFactory);\n  _appBootstrappedState = inject(_NgxsAppBootstrappedState);\n  _initStateHasBeenDispatched;\n  ngxsBootstrap(action, results) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (action instanceof InitState) {\n        this._initStateHasBeenDispatched = true;\n      } else if (\n      // This is a dev mode-only check that ensures the correct order of\n      // state initialization. The `NgxsModule.forRoot` or `provideStore` should\n      // always come first, followed by `forFeature` and `provideStates`. If the\n      // `UpdateState` is dispatched before the `InitState` is dispatched, it indicates\n      // that modules or providers are in an invalid order.\n      action instanceof UpdateState && !this._initStateHasBeenDispatched) {\n        console.error(getInvalidInitializationOrderMessage(action.addedStates));\n      }\n    }\n    // It does not need to unsubscribe because it is completed when the\n    // root injector is destroyed.\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(mergeMap(() => {\n      // If no states are provided, we safely complete the stream\n      // and do not proceed further.\n      if (!results) {\n        return EMPTY;\n      }\n      this._invokeInitOnStates(results.states);\n      return this._appBootstrappedState;\n    })).subscribe(appBootstrapped => {\n      if (appBootstrapped) {\n        this._invokeBootstrapOnStates(results.states);\n      }\n    });\n  }\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsOnChanges) {\n        // We are manually keeping track of the previous value\n        // within the subscribe block in order to drop the `pairwise()` operator.\n        let previousValue;\n        // It does not need to unsubscribe because it is completed when the\n        // root injector is destroyed.\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(\n        // Ensure initial state is captured\n        startWith(undefined),\n        // `skip` is using `filter` internally.\n        skip(1)).subscribe(currentValue => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          previousValue = currentValue;\n          instance.ngxsOnChanges(change);\n        });\n      }\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n      mappedStore.isInitialised = true;\n    }\n  }\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore.path);\n  }\n  /** @nocollapse */\n  static ɵfac = function LifecycleStateManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LifecycleStateManager)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LifecycleStateManager,\n    factory: LifecycleStateManager.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * This function is shared by both NgModule and standalone features.\n * When using `NgxsModule.forRoot` and `provideStore`, we can depend on the\n * same initialization functionality.\n */\nfunction rootStoreInitializer() {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    assertRootStoreNotInitialized();\n  }\n  // Override the RxJS `config.onUnhandledError` within the root store initializer,\n  // but only after other code has already executed.\n  // If users have a custom `config.onUnhandledError`, we might overwrite it too\n  // early and capture the original `config.onUnhandledError` before it is properly set.\n  installOnUnhandhedErrorHandler();\n  const prebootFns = inject(NGXS_PREBOOT_FNS, {\n    optional: true\n  }) || [];\n  prebootFns.forEach(prebootFn => prebootFn());\n  const factory = inject(StateFactory);\n  const internalStateOperations = inject(InternalStateOperations);\n  inject(Store);\n  inject(SelectFactory);\n  const states = inject(ROOT_STATE_TOKEN, {\n    optional: true\n  }) || [];\n  const lifecycleStateManager = inject(LifecycleStateManager);\n  // Add stores to the state graph and return their defaults.\n  const results = factory.addAndReturnDefaults(states);\n  internalStateOperations.setStateToTheCurrentWithNew(results);\n  // Connect our actions stream.\n  factory.connectActionHandlers();\n  // Dispatch the init action and invoke init and bootstrap functions after.\n  lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n}\n/**\n * This function is utilized by both NgModule and standalone features.\n * When using `NgxsModule.forFeature` and `provideStates`, we can depend on\n * the same initialization functionality.\n */\nfunction featureStatesInitializer() {\n  inject(Store);\n  const internalStateOperations = inject(InternalStateOperations);\n  const factory = inject(StateFactory);\n  const states = inject(FEATURE_STATE_TOKEN, {\n    optional: true\n  }) || [];\n  const lifecycleStateManager = inject(LifecycleStateManager);\n  // Since FEATURE_STATE_TOKEN is a multi token, we need to\n  // flatten it [[Feature1State, Feature2State], [Feature3State]].\n  const flattenedStates = states.reduce((total, values) => total.concat(values), []);\n  // add stores to the state graph and return their defaults.\n  const results = factory.addAndReturnDefaults(flattenedStates);\n  if (results.states.length) {\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Dispatch the update action and invoke init and bootstrap functions after.\n    lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n  }\n}\n/**\n * InjectionToken that registers the global Store.\n */\nconst NGXS_ROOT_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_ROOT_STORE_INITIALIZER' : '');\n/**\n * InjectionToken that registers feature states.\n */\nconst NGXS_FEATURE_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_FEATURE_STORE_INITIALIZER' : '');\nconst NGXS_ROOT_ENVIRONMENT_INITIALIZER = [{\n  provide: NGXS_ROOT_STORE_INITIALIZER,\n  useFactory: rootStoreInitializer\n}, provideEnvironmentInitializer(() => inject(NGXS_ROOT_STORE_INITIALIZER))];\n/**\n * The `NGXS_FEATURE_ENVIRONMENT_INITIALIZER` functions as an environment initializer\n * at the `Route` level. Angular Router creates an environment route injector for each\n * matched route where navigation occurs. The injector is created once, ensuring that\n * the feature states initialization only happens once as well.\n */\nconst NGXS_FEATURE_ENVIRONMENT_INITIALIZER = [{\n  provide: NGXS_FEATURE_STORE_INITIALIZER,\n  useFactory: featureStatesInitializer\n}, provideEnvironmentInitializer(() => inject(NGXS_FEATURE_STORE_INITIALIZER))];\n\n/**\n * @ignore\n */\nclass NgxsRootModule {\n  constructor() {\n    rootStoreInitializer();\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsRootModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsRootModule)();\n  };\n  /** @nocollapse */\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsRootModule\n  });\n  /** @nocollapse */\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], () => [], null);\n})();\n\n/**\n * @ignore\n */\nclass NgxsFeatureModule {\n  constructor() {\n    featureStatesInitializer();\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsFeatureModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsFeatureModule)();\n  };\n  /** @nocollapse */\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsFeatureModule\n  });\n  /** @nocollapse */\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], () => [], null);\n})();\n\n/**\n * This function provides the required providers when invoking `NgxsModule.forRoot`\n * or `provideStore`. It is shared between the NgModule and standalone APIs.\n */\nfunction getRootProviders(states, options) {\n  return [...states, {\n    provide: ROOT_STATE_TOKEN,\n    useValue: states\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    useFactory: () => {\n      const appBootstrappedState = inject(_NgxsAppBootstrappedState);\n      return () => appBootstrappedState.bootstrap();\n    },\n    multi: true\n  }, {\n    provide: NGXS_OPTIONS,\n    useValue: options\n  }];\n}\n\n/**\n * This function provides the required providers when calling `NgxsModule.forFeature`\n * or `provideStates`. It is shared between the NgModule and standalone APIs.\n */\nfunction getFeatureProviders(states) {\n  return [PluginManager, ...states, {\n    provide: FEATURE_STATE_TOKEN,\n    multi: true,\n    useValue: states\n  }];\n}\nclass NgxsModule {\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: getRootProviders(states, options)\n    };\n  }\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: getFeatureProviders(states)\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsModule)();\n  };\n  /** @nocollapse */\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsModule\n  });\n  /** @nocollapse */\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Decorates a method with action information.\n */\nfunction Action(actions, options) {\n  return (target, name,\n  // This parameter ensures that the decorated method has a call signature that could be passed an instance of the given action(s).\n  _descriptor) => {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      const isStaticMethod = _hasOwnProperty(target, 'prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = _ensureStoreMetadata(target.constructor);\n    const actionArray = Array.isArray(actions) ? actions : [actions];\n    for (const action of actionArray) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  return target => {\n    const stateClass = target;\n    const inherited = Object.getPrototypeOf(stateClass);\n    const meta = _ensureStoreMetadata(stateClass);\n    const mergedOptions = {\n      ...(inherited[_META_OPTIONS_KEY] || {}),\n      ...options\n    };\n    // Apply merged options to metadata.\n    mutateMetaData(meta, inherited, mergedOptions);\n    stateClass[_META_OPTIONS_KEY] = mergedOptions;\n  };\n}\n// Updates metadata using inherited and current options\nfunction mutateMetaData(meta, inherited, options) {\n  const {\n    name,\n    defaults,\n    children\n  } = options;\n  const stateName = typeof name === 'string' ? name : name?.getName?.() || null;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureStateNameIsValid(stateName);\n  }\n  if (_hasOwnProperty(inherited, _META_KEY)) {\n    const inheritedMeta = inherited[_META_KEY] || {};\n    meta.actions = {\n      ...meta.actions,\n      ...inheritedMeta.actions\n    };\n  }\n  meta.name = stateName;\n  meta.defaults = defaults;\n  meta.children = children;\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n *\n * Marked for removal. It's only used within `createSelectorFn`.\n */\nfunction propGetter(paths, config) {\n  if (config?.compatibility?.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n *\n * @deprecated\n * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target?.[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = _ensureSelectorMetadata(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = {\n    ...selectorMetaData\n  };\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return {\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}),\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}),\n    ...(selectorMetaData.getSelectorOptions() || {}),\n    ...explicitOptions\n  };\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor ||= Object.getOwnPropertyDescriptor(target, methodName);\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor ||= Object.getOwnPropertyDescriptor(target, key);\n    const originalFn = descriptor?.value;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      },\n      originalFn\n    };\n    return newDescriptor;\n  };\n}\nclass ActionDirector {\n  _registry = inject(_NgxsActionRegistry);\n  _actionHandlerFactory = inject(InternalActionHandlerFactory);\n  attachAction(stateToken, Action, handlerFn, options = {}) {\n    const actionHandler = this._actionHandlerFactory.createActionHandler(stateToken.getName(), handlerFn, options);\n    const detach = this._registry.register(Action.type, actionHandler);\n    return {\n      detach\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function ActionDirector_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ActionDirector)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActionDirector,\n    factory: ActionDirector.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ActionDirector, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n  /** @nocollapse */\n  static ɵfac = function NgxsDevelopmentModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxsDevelopmentModule)();\n  };\n  /** @nocollapse */\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsDevelopmentModule\n  });\n  /** @nocollapse */\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\nfunction withNgxsDevelopmentOptions(options) {\n  return makeEnvironmentProviders([NgxsUnhandledActionsLogger, {\n    provide: NGXS_DEVELOPMENT_OPTIONS,\n    useValue: options\n  }]);\n}\nfunction getMissingMetaDataError(selector, context = {}) {\n  const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n  if (!metadata) {\n    return new Error(`${context.prefix}The value provided as the ${context.noun} is not a valid selector.`);\n  }\n  return null;\n}\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const error = getMissingMetaDataError(selector, {\n    noun,\n    prefix\n  });\n  if (error) {\n    // If we have used this utility within a state class, we may be\n    //  before the @State or @Selector decorators have been applied.\n    //  wait until the next microtask to verify.\n    // Theoretically this situation is only encountered when the javascript\n    //  files are being loaded and we are outside the angular zone.\n    if (!NgZone.isInAngularZone()) {\n      Promise.resolve().then(() => {\n        const errorAgain = getMissingMetaDataError(selector, {\n          noun,\n          prefix\n        });\n        if (errorAgain) {\n          // Throw the originally captured error so that the stack trace shows the\n          // original utility call site.\n          console.error(error);\n        }\n      });\n    } else {\n      throw error;\n    }\n  }\n}\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelectorMap({\n      prefix: '[createModelSelector]',\n      selectorMap,\n      selectorKeys,\n      selectors\n    });\n  }\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\nfunction createPickSelector(selector, keys) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelector(selector, {\n      prefix: '[createPickSelector]'\n    });\n  }\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\nfunction createPropertySelectors(parentSelector) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelector(parentSelector, {\n      prefix: '[createPropertySelectors]',\n      noun: 'parent selector'\n    });\n  }\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s?.[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n  });\n}\n\n/**\n * This feature that contributes to app stability, which is required during\n * server-side rendering. With asynchronous actions being dispatched and handled,\n * Angular is unaware of them in zoneless mode and doesn't know whether the app is\n * still unstable. This may prematurely serialize the final HTML that is sent to the client.\n * Including `withNgxsPendingTasks` in your `provideStore` for your SSR\n * app will resolve the above issue.\n */\nfunction withNgxsPendingTasks() {\n  return withNgxsPreboot(() => {\n    const actions$ = inject(Actions);\n    const appRef = inject(ApplicationRef);\n    const pendingTasks = inject(PendingTasks);\n    // Removing a pending task via the public API forces a scheduled tick, ensuring that\n    // stability is async and delayed until there was at least an opportunity to run\n    // app synchronization.\n    // Adding a new task every time an action is dispatched drastically increases the\n    // number of change detection cycles because removing a task schedules a new change\n    // detection cycle.\n    // If 10 actions are dispatched with synchronous action handlers, this would trigger\n    // 10 change detection cycles in a row, potentially leading to an\n    // `INFINITE_CHANGE_DETECTION` error.\n    let removeTask = null;\n    const executedActions = new Set();\n    // If the app is forcely destroyed before all actions are completed,\n    // we clean up the set of actions being executed to prevent memory leaks\n    // and remove the pending task to stabilize the app.\n    appRef.onDestroy(() => executedActions.clear());\n    let isStable = false;\n    appRef.whenStable().then(() => {\n      isStable = true;\n    });\n    const subscription = actions$.pipe(filter(context => {\n      if (context.status === ActionStatus.Dispatched) {\n        executedActions.add(context.action);\n        removeTask ||= pendingTasks.add();\n        return false;\n      } else {\n        return true;\n      }\n    }),\n    // Every time an action is completed, we debounce the stream to ensure only one\n    // task is removed, even if multiple synchronous actions are completed in a row.\n    // We use `buffer` to collect action contexts because, if we only use\n    // `debounceTime(0)`, we may lose action contexts that are never removed from the set.\n    buffer(actions$.pipe(debounceTime(0)))).subscribe(contexts => {\n      for (const context of contexts) {\n        if (!executedActions.has(context.action)) {\n          continue;\n        }\n        executedActions.delete(context.action);\n        // Mark app as stable once all of the debounced actions have completed.\n        if (executedActions.size === 0) {\n          removeTask?.();\n          removeTask = null;\n          if (isStable) {\n            // Stop contributing to stability once the application has become stable,\n            // which may happen on the server before the platform is destroyed or in\n            // the browser once hydration is complete.\n            subscription.unsubscribe();\n          }\n        }\n      }\n    });\n  });\n}\nfunction provideStore(states = [], ...optionsAndFeatures) {\n  const features = [];\n  // Options are empty by default (see `forRoot`).\n  let options = {};\n  if (optionsAndFeatures.length > 0) {\n    if (isEnvironmentProvider(optionsAndFeatures[0])) {\n      features.push(...optionsAndFeatures);\n    } else {\n      options = optionsAndFeatures[0];\n      features.push(...optionsAndFeatures.slice(1));\n    }\n  }\n  return makeEnvironmentProviders([...getRootProviders(states, options), NGXS_ROOT_ENVIRONMENT_INITIALIZER, features]);\n}\nfunction isEnvironmentProvider(target) {\n  return !!target.ɵproviders;\n}\n\n/**\n * This version serves as a standalone alternative to `NgxsModule.forFeature`.\n * It can be used in a similar manner to register feature states, but at the\n * `Route` providers level:\n *\n * ```ts\n * const routes: Routes = [\n *   {\n *     path: 'products',\n *     loadComponent: async () => {...},\n *     providers: [provideStates([ProductsState])]\n *   }\n * ];\n * ```\n *\n * To lazy-load feature states at the route level,\n * please refer to the `lazyProvider` utility function.\n */\nfunction provideStates(states, ...features) {\n  return makeEnvironmentProviders([...getFeatureProviders(states), features, NGXS_FEATURE_ENVIRONMENT_INITIALIZER]);\n}\n\n/**\n * This function registers a custom global plugin for the state.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPlugin(LogoutPlugin)\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPlugin(plugin) {\n  return makeEnvironmentProviders([_isPluginClass(plugin) ? {\n    provide: NGXS_PLUGINS,\n    useClass: plugin,\n    multi: true\n  } : {\n    provide: NGXS_PLUGINS,\n    useValue: plugin,\n    multi: true\n  },\n  // We should inject the `PluginManager` to retrieve `NGXS_PLUGINS` and\n  // register those plugins. The plugin can be added from inside the child\n  // route, so the plugin manager should be re-injected.\n  provideEnvironmentInitializer(() => inject(PluginManager))]);\n}\n\n/**\n * This function serves as a utility and has multiple purposes.\n * Firstly, it allows you to select properties from the state class\n * without having to inject the store class and use `this.store.selectSignal`,\n * resulting in a more concise implementation. Secondly, it can be used with\n * other solutions such as NgRx signal store with its `signalStoreFeature` or\n * `withComputed` functionalities.\n *\n * Please note that it's named `select` instead of `selectSignal` because\n * signals are evolving into first-class primitives in Angular, displacing other\n * primitives such as observables. Observables represent a stream of events,\n * whereas signals represent a single value changing over time.\n */\nfunction select(selector) {\n  return inject(Store).selectSignal(selector);\n}\nfunction dispatch(ActionType) {\n  const store = inject(Store);\n  return (...args) => store.dispatch(new ActionType(...args));\n}\nfunction createSelectMap(selectorMap) {\n  const store = inject(Store);\n  return Object.entries(selectorMap).reduce((accumulator, [key, selector]) => {\n    accumulator[key] = store.selectSignal(selector);\n    return accumulator;\n  }, {});\n}\nfunction createDispatchMap(actionMap) {\n  return Object.entries(actionMap).reduce((accumulator, [key, ActionType]) => {\n    accumulator[key] = dispatch(ActionType);\n    return accumulator;\n  }, {});\n}\nfunction isWrappedDefaultExport(value) {\n  return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\nconst REGISTERED_PROVIDERS = new InjectionToken('', {\n  providedIn: 'root',\n  factory: () => {\n    const registeredProviders = new Set();\n    inject(ApplicationRef).onDestroy(() => registeredProviders.clear());\n    return registeredProviders;\n  }\n});\n/**\n * This function serves as a utility to lazy-load providers at the injection\n * context level — for example, at the route level. If the feature state needs\n * to be provided in more than one place, it might be indirectly included in\n * the main bundle, which we want to avoid. This function can be used at the\n * guard level to lazy-load the state provider before resolvers run and the\n * component is initialized:\n *\n * ```ts\n * const routes = [\n *   {\n *     path: 'home',\n *     loadComponent: () => import(...),\n *     canActivate: [\n *       lazyProvider(async () => (await import('path-to-state-library')).invoicesStateProvider)\n *     ]\n *   }\n * ];\n * ```\n *\n * Where `invoicesStateProvider` is the following:\n *\n * ```ts\n * // path-to-state-library/index.ts\n *\n * export const invoicesStateProvider = provideStates([InvoicesState]);\n * ```\n */\nfunction lazyProvider(factory) {\n  return async () => {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertInInjectionContext(lazyProvider);\n    }\n    const appRef = inject(ApplicationRef);\n    const parentInjector = inject(EnvironmentInjector);\n    const registeredProviders = inject(REGISTERED_PROVIDERS);\n    const provider = maybeUnwrapDefaultExport(await factory());\n    if (registeredProviders.has(provider)) {\n      return true;\n    }\n    registeredProviders.add(provider);\n    const injector = createEnvironmentInjector([provider], parentInjector);\n    appRef.onDestroy(() => injector.destroy());\n    return true;\n  };\n}\n\n// Backward compatibility is provided because these tokens are used by third-party\n// libraries. We expose a separate function to allow tree-shaking of these tokens\n// if they are not used in standard applications that do not rely on them.\nfunction ɵprovideNgxsInternalStateTokens() {\n  return makeEnvironmentProviders([{\n    provide: _NGXS_STATE_CONTEXT_FACTORY,\n    useExisting: StateContextFactory\n  }, {\n    provide: _NGXS_STATE_FACTORY,\n    useExisting: StateFactory\n  }]);\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, ActionDirector, ActionStatus, Actions, NgxsConfig, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NgxsUnhandledErrorHandler, Select, Selector, SelectorOptions, State, Store, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, lazyProvider, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPendingTasks, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule, ɵprovideNgxsInternalStateTokens };\n"],
  "mappings": "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",
  "names": ["handlers", "ActionStatus", "config", "propGetter", "Action"]
}
