{"version":3,"file":"ngxs-storage-plugin.mjs","sources":["../../../packages/storage-plugin/src/internals.ts","../../../packages/storage-plugin/src/keys-manager.ts","../../../packages/storage-plugin/src/storage.plugin.ts","../../../packages/storage-plugin/src/storage.module.ts","../../../packages/storage-plugin/src/with-storage-feature.ts","../../../packages/storage-plugin/src/engines.ts","../../../packages/storage-plugin/index.ts","../../../packages/storage-plugin/ngxs-storage-plugin.ts"],"sourcesContent":["import {\n  ɵDEFAULT_STATE_KEY,\n  StorageOption,\n  StorageEngine,\n  NgxsStoragePluginOptions,\n  ɵNgxsTransformedStoragePluginOptions\n} from '@ngxs/storage-plugin/internals';\n\ndeclare const ngServerMode: boolean;\n\nexport function storageOptionsFactory(\n  options: NgxsStoragePluginOptions\n): ɵNgxsTransformedStoragePluginOptions {\n  return {\n    storage: StorageOption.LocalStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize: obj => obj,\n    afterDeserialize: obj => obj,\n    ...options,\n    keys: options.keys === '*' ? [ɵDEFAULT_STATE_KEY] : options.keys\n  };\n}\n\nexport function engineFactory(options: NgxsStoragePluginOptions): StorageEngine | null {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return null;\n  }\n\n  if (options.storage === StorageOption.LocalStorage) {\n    return localStorage;\n  } else if (options.storage === StorageOption.SessionStorage) {\n    return sessionStorage;\n  }\n\n  return null;\n}\n\nexport function getStorageKey(key: string, options?: NgxsStoragePluginOptions): string {\n  // Prepends the `namespace` option to any key if it's been provided by a user.\n  // So `@@STATE` becomes `my-app:@@STATE`.\n  return options?.namespace ? `${options.namespace}:${key}` : key;\n}\n","import { Injectable, Injector, inject } from '@angular/core';\nimport {\n  STORAGE_ENGINE,\n  StorageEngine,\n  StorageKey,\n  ɵextractStringKey,\n  ɵisKeyWithExplicitEngine,\n  ɵNGXS_STORAGE_PLUGIN_OPTIONS\n} from '@ngxs/storage-plugin/internals';\n\ninterface KeyWithEngine {\n  key: string;\n  engine: StorageEngine;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ɵNgxsStoragePluginKeysManager {\n  /** Store keys separately in a set so we're able to check if the key already exists. */\n  private readonly _keys = new Set<string>();\n\n  private readonly _injector = inject(Injector);\n\n  private readonly _keysWithEngines: KeyWithEngine[] = [];\n\n  constructor() {\n    const { keys } = inject(ɵNGXS_STORAGE_PLUGIN_OPTIONS);\n    this.addKeys(keys);\n  }\n\n  getKeysWithEngines() {\n    // Spread to prevent external code from directly modifying the internal state.\n    return [...this._keysWithEngines];\n  }\n\n  addKeys(storageKeys: StorageKey[]): void {\n    for (const storageKey of storageKeys) {\n      const key = ɵextractStringKey(storageKey);\n\n      // The user may call `withStorageFeature` with the same state multiple times.\n      // Let's prevent duplicating state names in the `keysWithEngines` list.\n      // Please note that calling provideStates multiple times with the same state is\n      // acceptable behavior. This may occur because the state could be necessary at the\n      // feature level, and different parts of the application might require its registration.\n      // Consequently, `withStorageFeature` may also be called multiple times.\n      if (this._keys.has(key)) {\n        continue;\n      }\n\n      this._keys.add(key);\n\n      const engine = ɵisKeyWithExplicitEngine(storageKey)\n        ? this._injector.get(storageKey.engine)\n        : this._injector.get(STORAGE_ENGINE);\n\n      this._keysWithEngines.push({ key, engine });\n    }\n  }\n}\n","import { Injectable, inject } from '@angular/core';\nimport { ɵhasOwnProperty, ɵPlainObject } from '@ngxs/store/internals';\nimport {\n  NgxsPlugin,\n  setValue,\n  getValue,\n  InitState,\n  UpdateState,\n  actionMatcher,\n  NgxsNextPluginFn\n} from '@ngxs/store/plugins';\nimport {\n  ɵDEFAULT_STATE_KEY,\n  ɵALL_STATES_PERSISTED,\n  ɵNGXS_STORAGE_PLUGIN_OPTIONS\n} from '@ngxs/storage-plugin/internals';\nimport { tap } from 'rxjs';\n\nimport { getStorageKey } from './internals';\nimport { ɵNgxsStoragePluginKeysManager } from './keys-manager';\n\ndeclare const ngDevMode: boolean;\ndeclare const ngServerMode: boolean;\n\n@Injectable()\nexport class NgxsStoragePlugin implements NgxsPlugin {\n  private _keysManager = inject(ɵNgxsStoragePluginKeysManager);\n  private _options = inject(ɵNGXS_STORAGE_PLUGIN_OPTIONS);\n  private _allStatesPersisted = inject(ɵALL_STATES_PERSISTED);\n\n  handle(state: any, event: any, next: NgxsNextPluginFn) {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return next(state, event);\n    }\n\n    const matches = actionMatcher(event);\n    const isInitAction = matches(InitState);\n    const isUpdateAction = matches(UpdateState);\n    const isInitOrUpdateAction = isInitAction || isUpdateAction;\n    let hasMigration = false;\n\n    if (isInitOrUpdateAction) {\n      const addedStates: ɵPlainObject = isUpdateAction && event.addedStates;\n\n      for (const { key, engine } of this._keysManager.getKeysWithEngines()) {\n        // We're checking what states have been added by NGXS and if any of these states should be handled by\n        // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n        // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n        // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n        if (!this._allStatesPersisted && addedStates) {\n          // We support providing keys that can be deeply nested via dot notation, for instance,\n          // `keys: ['myState.myProperty']` is a valid key.\n          // The state name should always go first. The below code checks if the `key` includes dot\n          // notation and extracts the state name out of the key.\n          // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n          const dotNotationIndex = key.indexOf(DOT);\n          const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n          if (!ɵhasOwnProperty(addedStates, stateName)) continue;\n        }\n\n        const storageKey = getStorageKey(key, this._options);\n        let storedValue: any = engine.getItem(storageKey);\n\n        if (storedValue !== 'undefined' && storedValue != null) {\n          try {\n            const newVal = this._options.deserialize!(storedValue);\n            storedValue = this._options.afterDeserialize!(newVal, key);\n          } catch {\n            typeof ngDevMode !== 'undefined' &&\n              ngDevMode &&\n              console.error(\n                `Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `,\n                storedValue\n              );\n\n            storedValue = {};\n          }\n\n          this._options.migrations?.forEach(strategy => {\n            const versionMatch =\n              strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n            const keyMatch =\n              (!strategy.key && this._allStatesPersisted) || strategy.key === key;\n            if (versionMatch && keyMatch) {\n              storedValue = strategy.migrate(storedValue);\n              hasMigration = true;\n            }\n          });\n\n          if (this._allStatesPersisted) {\n            storedValue = this._hydrateSelectivelyOnUpdate(storedValue, addedStates);\n            state = { ...state, ...storedValue };\n          } else {\n            state = setValue(state, key, storedValue);\n          }\n        }\n      }\n    }\n\n    return next(state, event).pipe(\n      tap(nextState => {\n        if (isInitOrUpdateAction && !hasMigration) {\n          return;\n        }\n\n        for (const { key, engine } of this._keysManager.getKeysWithEngines()) {\n          let storedValue = nextState;\n\n          const storageKey = getStorageKey(key, this._options);\n\n          if (key !== ɵDEFAULT_STATE_KEY) {\n            storedValue = getValue(nextState, key);\n          }\n\n          try {\n            const newStoredValue = this._options.beforeSerialize!(storedValue, key);\n            engine.setItem(storageKey, this._options.serialize!(newStoredValue));\n          } catch (error: any) {\n            if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n              if (\n                error &&\n                (error.name === 'QuotaExceededError' ||\n                  error.name === 'NS_ERROR_DOM_QUOTA_REACHED')\n              ) {\n                console.error(\n                  `The ${storageKey} store value exceeds the browser storage quota: `,\n                  storedValue\n                );\n              } else {\n                console.error(\n                  `Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `,\n                  storedValue\n                );\n              }\n            }\n          }\n        }\n      })\n    );\n  }\n\n  private _hydrateSelectivelyOnUpdate(storedValue: any, addedStates: ɵPlainObject) {\n    // The `UpdateState` action is triggered whenever a feature state is added.\n    // The condition below is only satisfied when this action is triggered.\n    // Let's consider two states: `counter` and `@ngxs/router-plugin` state.\n    // When `provideStore` is called, `CounterState` is provided at the root level,\n    // while `@ngxs/router-plugin` is provided as a feature state. Previously, the storage\n    // plugin might have stored the value of the counter state as `10`. If `CounterState`\n    // implements the `ngxsOnInit` hook and sets the state to `999`, the storage plugin will\n    // reset the entire state when the `RouterState` is registered.\n    // Consequently, the `counter` state will revert back to `10` instead of `999`.\n\n    if (!storedValue || !addedStates || Object.keys(addedStates).length === 0) {\n      // Nothing to update if `addedStates` object is empty.\n      return storedValue;\n    }\n\n    // The `storedValue` can be the entire state when the default state key\n    // is used. However, if `addedStates` only contains the `router` value,\n    // we only want to merge the state with that `router` value.\n    // Given the `storedValue` is an object:\n    // `{ counter: 10, router: {...} }`\n    // This will only select the `router` object from the `storedValue`,\n    // avoiding unnecessary rehydration of the `counter` state.\n    return Object.keys(addedStates).reduce(\n      (accumulator, addedState) => {\n        if (ɵhasOwnProperty(storedValue, addedState)) {\n          accumulator[addedState] = storedValue[addedState];\n        }\n        return accumulator;\n      },\n      <ɵPlainObject>{}\n    );\n  }\n}\n\nconst DOT = '.';\n","import {\n  NgModule,\n  ModuleWithProviders,\n  EnvironmentProviders,\n  makeEnvironmentProviders\n} from '@angular/core';\nimport { withNgxsPlugin } from '@ngxs/store';\nimport {\n  ɵUSER_OPTIONS,\n  STORAGE_ENGINE,\n  ɵNGXS_STORAGE_PLUGIN_OPTIONS,\n  NgxsStoragePluginOptions\n} from '@ngxs/storage-plugin/internals';\n\nimport { NgxsStoragePlugin } from './storage.plugin';\nimport { engineFactory, storageOptionsFactory } from './internals';\n\n@NgModule()\nexport class NgxsStoragePluginModule {\n  static forRoot(\n    options: NgxsStoragePluginOptions\n  ): ModuleWithProviders<NgxsStoragePluginModule> {\n    return {\n      ngModule: NgxsStoragePluginModule,\n      providers: [\n        withNgxsPlugin(NgxsStoragePlugin),\n        {\n          provide: ɵUSER_OPTIONS,\n          useValue: options\n        },\n        {\n          provide: ɵNGXS_STORAGE_PLUGIN_OPTIONS,\n          useFactory: storageOptionsFactory,\n          deps: [ɵUSER_OPTIONS]\n        },\n        {\n          provide: STORAGE_ENGINE,\n          useFactory: engineFactory,\n          deps: [ɵNGXS_STORAGE_PLUGIN_OPTIONS]\n        }\n      ]\n    };\n  }\n}\n\nexport function withNgxsStoragePlugin(\n  options: NgxsStoragePluginOptions\n): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    withNgxsPlugin(NgxsStoragePlugin),\n    {\n      provide: ɵUSER_OPTIONS,\n      useValue: options\n    },\n    {\n      provide: ɵNGXS_STORAGE_PLUGIN_OPTIONS,\n      useFactory: storageOptionsFactory,\n      deps: [ɵUSER_OPTIONS]\n    },\n    {\n      provide: STORAGE_ENGINE,\n      useFactory: engineFactory,\n      deps: [ɵNGXS_STORAGE_PLUGIN_OPTIONS]\n    }\n  ]);\n}\n","import { inject, EnvironmentProviders, provideEnvironmentInitializer } from '@angular/core';\nimport { StorageKey, ɵALL_STATES_PERSISTED } from '@ngxs/storage-plugin/internals';\n\nimport { ɵNgxsStoragePluginKeysManager } from './keys-manager';\n\ndeclare const ngDevMode: boolean;\n\nexport function withStorageFeature(storageKeys: StorageKey[]): EnvironmentProviders {\n  return provideEnvironmentInitializer(() => {\n    const allStatesPersisted = inject(ɵALL_STATES_PERSISTED);\n\n    if (allStatesPersisted) {\n      if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const message =\n          'The NGXS storage plugin is currently persisting all states because the `keys` ' +\n          'option was explicitly set to `*` at the root level. To selectively persist states, ' +\n          'consider explicitly specifying them, allowing for addition at the feature level.';\n\n        console.error(message);\n      }\n\n      // We should prevent the addition of any feature states to persistence\n      // if the `keys` property is set to `*`, as this could disrupt the algorithm\n      // used in the storage plugin. Instead, we should log an error in development\n      // mode. In production, it should continue to function, but act as a no-op.\n      return;\n    }\n\n    inject(ɵNgxsStoragePluginKeysManager).addKeys(storageKeys);\n  });\n}\n","import { InjectionToken } from '@angular/core';\nimport { StorageEngine } from '@ngxs/storage-plugin/internals';\n\ndeclare const ngDevMode: boolean;\ndeclare const ngServerMode: boolean;\n\nexport const LOCAL_STORAGE_ENGINE = /* @__PURE__ */ new InjectionToken<StorageEngine | null>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'LOCAL_STORAGE_ENGINE' : '',\n  {\n    providedIn: 'root',\n    factory: () => (typeof ngServerMode !== 'undefined' && ngServerMode ? null : localStorage)\n  }\n);\n\nexport const SESSION_STORAGE_ENGINE = /* @__PURE__ */ new InjectionToken<StorageEngine | null>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'SESSION_STORAGE_ENGINE' : '',\n  {\n    providedIn: 'root',\n    factory: () =>\n      typeof ngServerMode !== 'undefined' && ngServerMode ? null : sessionStorage\n  }\n);\n","/**\n * The public api for consumers of @ngxs/storage-plugin\n */\nexport * from './src/public_api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ɵDEFAULT_STATE_KEY","ɵNGXS_STORAGE_PLUGIN_OPTIONS","ɵextractStringKey","ɵisKeyWithExplicitEngine","ɵALL_STATES_PERSISTED","ɵhasOwnProperty","ɵUSER_OPTIONS"],"mappings":"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"}