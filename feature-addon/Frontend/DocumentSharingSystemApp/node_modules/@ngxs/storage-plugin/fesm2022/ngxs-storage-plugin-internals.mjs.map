{"version":3,"file":"ngxs-storage-plugin-internals.mjs","sources":["../../../packages/storage-plugin/internals/src/symbols.ts","../../../packages/storage-plugin/internals/src/storage-key.ts","../../../packages/storage-plugin/internals/src/ngxs-storage-plugin-internals.ts"],"sourcesContent":["import { InjectionToken, inject } from '@angular/core';\n\nimport { StorageKey } from './storage-key';\n\n/**\n * The following key is used to store the entire serialized\n * state when no specific state is provided.\n */\nexport const ɵDEFAULT_STATE_KEY = '@@STATE';\n\ndeclare const ngDevMode: boolean;\n\nexport enum StorageOption {\n  LocalStorage,\n  SessionStorage\n}\n\nexport interface NgxsStoragePluginOptions {\n  /**\n   * Keys for the state slice to store in the storage engine.\n   */\n  keys: '*' | StorageKey[];\n\n  /**\n   * The namespace is used to prefix the key for the state slice. This is\n   * necessary when running micro frontend applications which use storage plugin.\n   * The namespace will eliminate the conflict between keys that might overlap.\n   */\n  namespace?: string;\n\n  /**\n   * Storage engine to use. Deaults to localStorage but can provide\n   *\n   * sessionStorage or custom implementation of the StorageEngine interface\n   */\n  storage?: StorageOption;\n\n  /**\n   * Migration strategies.\n   */\n  migrations?: {\n    /**\n     * Version to key off.\n     */\n    version: number | string;\n\n    /**\n     * Method to migrate the previous state.\n     */\n    migrate: (state: any) => any;\n\n    /**\n     * Key to migrate.\n     */\n    key?: string;\n\n    /**\n     * Key for the version. Defaults to 'version'.\n     */\n    versionKey?: string;\n  }[];\n\n  /**\n   * Serailizer for the object before its pushed into the engine.\n   */\n  serialize?(obj: any): string;\n\n  /**\n   * Deserializer for the object before its pulled out of the engine.\n   */\n  deserialize?(obj: any): any;\n\n  /**\n   * Method to alter object before serialization.\n   */\n  beforeSerialize?(obj: any, key: string): any;\n\n  /**\n   * Method to alter object after deserialization.\n   */\n  afterDeserialize?(obj: any, key: string): any;\n}\n\nexport interface ɵNgxsTransformedStoragePluginOptions extends NgxsStoragePluginOptions {\n  keys: StorageKey[];\n}\n\nexport const ɵUSER_OPTIONS = new InjectionToken<NgxsStoragePluginOptions>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'USER_OPTIONS' : ''\n);\n\n// Determines whether all states in the NGXS registry should be persisted or not.\nexport const ɵALL_STATES_PERSISTED = new InjectionToken<boolean>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'ALL_STATES_PERSISTED' : '',\n  {\n    providedIn: 'root',\n    factory: () => inject(ɵUSER_OPTIONS).keys === '*'\n  }\n);\n\nexport const ɵNGXS_STORAGE_PLUGIN_OPTIONS =\n  new InjectionToken<ɵNgxsTransformedStoragePluginOptions>(\n    typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_STORAGE_PLUGIN_OPTIONS' : ''\n  );\n\nexport const STORAGE_ENGINE = new InjectionToken<StorageEngine>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'STORAGE_ENGINE' : ''\n);\n\nexport interface StorageEngine {\n  getItem(key: string): any;\n  setItem(key: string, value: any): void;\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport { StateToken } from '@ngxs/store';\nimport { ɵhasOwnProperty, ɵMETA_OPTIONS_KEY, ɵStateClass } from '@ngxs/store/internals';\n\nimport { StorageEngine } from './symbols';\n\n/** This enables the user to provide a storage engine per individual key. */\nexport interface KeyWithExplicitEngine {\n  key: string | ɵStateClass | StateToken<any>;\n  engine: Type<StorageEngine> | InjectionToken<StorageEngine>;\n}\n\n/** Determines whether the provided key has the following structure. */\nexport function ɵisKeyWithExplicitEngine(key: any): key is KeyWithExplicitEngine {\n  return !!key?.engine;\n}\n\n/**\n * This tuples all of the possible types allowed in the `key` property.\n * This is not exposed publicly and used internally only.\n */\nexport type StorageKey = string | ɵStateClass | StateToken<any> | KeyWithExplicitEngine;\n\nexport function ɵextractStringKey(storageKey: StorageKey): string {\n  // Extract the actual key out of the `{ key, engine }` structure.\n  if (ɵisKeyWithExplicitEngine(storageKey)) {\n    storageKey = storageKey.key;\n  }\n\n  // Given the `storageKey` is a class, for instance, `AuthState`.\n  // We should retrieve its metadata and the `name` property.\n  // The `name` property might be a string (state name) or a state token.\n  if (ɵhasOwnProperty(storageKey, ɵMETA_OPTIONS_KEY)) {\n    storageKey = (storageKey as any)[ɵMETA_OPTIONS_KEY].name;\n  }\n\n  return storageKey instanceof StateToken ? storageKey.getName() : <string>storageKey;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ɵhasOwnProperty","ɵMETA_OPTIONS_KEY"],"mappings":";;;;AAIA;;;AAGG;AACI,MAAM,kBAAkB,GAAG;IAItB;AAAZ,CAAA,UAAY,aAAa,EAAA;AACvB,IAAA,aAAA,CAAA,aAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAY;AACZ,IAAA,aAAA,CAAA,aAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAc;AAChB,CAAC,EAHW,aAAa,KAAb,aAAa,GAGxB,EAAA,CAAA,CAAA;MAwEY,aAAa,GAAG,IAAI,cAAc,CAC7C,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,GAAG,cAAc,GAAG,EAAE;AAGrE;MACa,qBAAqB,GAAG,IAAI,cAAc,CACrD,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,GAAG,sBAAsB,GAAG,EAAE,EAC3E;AACE,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,MAAM,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,KAAK;AAC/C,CAAA;MAGU,4BAA4B,GACvC,IAAI,cAAc,CAChB,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,GAAG,6BAA6B,GAAG,EAAE;MAGzE,cAAc,GAAG,IAAI,cAAc,CAC9C,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,GAAG,gBAAgB,GAAG,EAAE;;AC9FvE;AACM,SAAU,wBAAwB,CAAC,GAAQ,EAAA;AAC/C,IAAA,OAAO,CAAC,CAAC,GAAG,EAAE,MAAM;AACtB;AAQM,SAAU,iBAAiB,CAAC,UAAsB,EAAA;;AAEtD,IAAA,IAAI,wBAAwB,CAAC,UAAU,CAAC,EAAE;AACxC,QAAA,UAAU,GAAG,UAAU,CAAC,GAAG;;;;;AAM7B,IAAA,IAAIA,eAAe,CAAC,UAAU,EAAEC,iBAAiB,CAAC,EAAE;AAClD,QAAA,UAAU,GAAI,UAAkB,CAACA,iBAAiB,CAAC,CAAC,IAAI;;AAG1D,IAAA,OAAO,UAAU,YAAY,UAAU,GAAG,UAAU,CAAC,OAAO,EAAE,GAAW,UAAU;AACrF;;ACrCA;;AAEG;;;;"}