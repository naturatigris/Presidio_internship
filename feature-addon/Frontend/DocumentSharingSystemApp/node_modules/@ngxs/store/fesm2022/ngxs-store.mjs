import * as i0 from '@angular/core';
import { inject, Injectable, DestroyRef, NgZone, Injector, runInInjectionContext, InjectionToken, ErrorHandler, ɵisPromise as _isPromise, computed, makeEnvironmentProviders, provideEnvironmentInitializer, NgModule, APP_BOOTSTRAP_LISTENER, ApplicationRef, PendingTasks, assertInInjectionContext, EnvironmentInjector, createEnvironmentInjector } from '@angular/core';
import { config, Observable, Subject, of, forkJoin, map, shareReplay, filter, take, mergeMap, EMPTY, from, isObservable, defaultIfEmpty, takeUntil, finalize, catchError, distinctUntilChanged, startWith, skip, buffer, debounceTime } from 'rxjs';
import { ɵwrapObserverCalls as _wrapObserverCalls, ɵOrderedSubject as _OrderedSubject, ɵStateStream as _StateStream, ɵhasOwnProperty as _hasOwnProperty, ɵmemoize as _memoize, ɵgetStoreMetadata as _getStoreMetadata, ɵgetSelectorMetadata as _getSelectorMetadata, ɵMETA_KEY as _META_KEY, ɵINITIAL_STATE_TOKEN as _INITIAL_STATE_TOKEN, ɵNgxsActionRegistry as _NgxsActionRegistry, ɵNgxsAppBootstrappedState as _NgxsAppBootstrappedState, ɵensureStoreMetadata as _ensureStoreMetadata, ɵMETA_OPTIONS_KEY as _META_OPTIONS_KEY, ɵensureSelectorMetadata as _ensureSelectorMetadata, ɵNGXS_STATE_CONTEXT_FACTORY as _NGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY as _NGXS_STATE_FACTORY } from '@ngxs/store/internals';
export { StateToken } from '@ngxs/store/internals';
import { NGXS_PLUGINS, getActionTypeFromInstance, InitState, UpdateState, setValue, getValue, ɵisPluginClass as _isPluginClass } from '@ngxs/store/plugins';
export { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';
import { isStateOperator } from '@ngxs/store/operators';

class PluginManager {
    plugins = [];
    _parentManager = inject(PluginManager, {
        optional: true,
        skipSelf: true
    });
    _pluginHandlers = inject(NGXS_PLUGINS, {
        optional: true
    });
    constructor() {
        this.registerHandlers();
    }
    get _rootPlugins() {
        return this._parentManager?.plugins || this.plugins;
    }
    registerHandlers() {
        const pluginHandlers = this.getPluginHandlers();
        this._rootPlugins.push(...pluginHandlers);
    }
    getPluginHandlers() {
        const handlers = this._pluginHandlers || [];
        return handlers.map((plugin) => (plugin.handle ? plugin.handle.bind(plugin) : plugin));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: PluginManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: PluginManager, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: PluginManager, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

/**
 * Returns operator that will run
 * `subscribe` outside of the ngxs execution context
 */
function leaveNgxs(ngxsExecutionStrategy) {
    return _wrapObserverCalls(fn => ngxsExecutionStrategy.leave(fn));
}

const ɵɵunhandledRxjsErrorCallbacks = new WeakMap();
let installed = false;
function installOnUnhandhedErrorHandler() {
    if (installed) {
        return;
    }
    const existingHandler = config.onUnhandledError;
    config.onUnhandledError = function (error) {
        const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);
        if (unhandledErrorCallback) {
            unhandledErrorCallback();
        }
        else if (existingHandler) {
            existingHandler.call(this, error);
        }
        else {
            throw error;
        }
    };
    installed = true;
}
function executeUnhandledCallback(error) {
    const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);
    if (unhandledErrorCallback) {
        unhandledErrorCallback();
        return true;
    }
    return false;
}
function assignUnhandledCallback(error, callback) {
    // Since the error can be essentially anything, we must ensure that we only
    // handle objects, as weak maps do not allow any other key type besides objects.
    // The error can also be a string if thrown in the following manner: `throwError('My Error')`.
    if (error && typeof error === 'object') {
        let hasBeenCalled = false;
        ɵɵunhandledRxjsErrorCallbacks.set(error, () => {
            if (!hasBeenCalled) {
                hasBeenCalled = true;
                callback();
            }
        });
    }
    return error;
}

function fallbackSubscriber(ngZone) {
    return (source) => {
        let subscription = source.subscribe({
            error: error => {
                ngZone.runOutsideAngular(() => {
                    // This is necessary to schedule a microtask to ensure that synchronous
                    // errors are not reported before the real subscriber arrives. If an error
                    // is thrown synchronously in any action, it will be reported to the error
                    // handler regardless. Since RxJS reports unhandled errors asynchronously,
                    // implementing a microtask ensures that we are also safe in this scenario.
                    queueMicrotask(() => {
                        if (subscription) {
                            executeUnhandledCallback(error);
                        }
                    });
                });
            }
        });
        return new Observable(subscriber => {
            // Now that there is a real subscriber, we can unsubscribe our pro-active subscription
            subscription?.unsubscribe();
            subscription = null;
            return source.subscribe(subscriber);
        });
    };
}

/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
class InternalDispatchedActionResults extends Subject {
    constructor() {
        super();
        // Complete the subject once the root injector is destroyed to ensure
        // there are no active subscribers that would receive events or perform
        // any actions after the application is destroyed.
        inject(DestroyRef).onDestroy(() => this.complete());
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatchedActionResults, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatchedActionResults, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatchedActionResults, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

class InternalNgxsExecutionStrategy {
    _ngZone = inject(NgZone);
    enter(func) {
        if (typeof ngServerMode !== 'undefined' && ngServerMode) {
            return this._runInsideAngular(func);
        }
        return this._runOutsideAngular(func);
    }
    leave(func) {
        return this._runInsideAngular(func);
    }
    _runInsideAngular(func) {
        if (NgZone.isInAngularZone()) {
            return func();
        }
        return this._ngZone.run(func);
    }
    _runOutsideAngular(func) {
        if (NgZone.isInAngularZone()) {
            return this._ngZone.runOutsideAngular(func);
        }
        return func();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalNgxsExecutionStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalNgxsExecutionStrategy, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalNgxsExecutionStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * Status of a dispatched action
 */
var ActionStatus;
(function (ActionStatus) {
    ActionStatus["Dispatched"] = "DISPATCHED";
    ActionStatus["Successful"] = "SUCCESSFUL";
    ActionStatus["Canceled"] = "CANCELED";
    ActionStatus["Errored"] = "ERRORED";
})(ActionStatus || (ActionStatus = {}));
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
class InternalActions extends _OrderedSubject {
    // This subject will be the first to know about the dispatched action, its purpose is for
    // any logic that must be executed before action handlers are invoked (i.e., cancelation).
    dispatched$ = new Subject();
    constructor() {
        super();
        this.subscribe(ctx => {
            if (ctx.status === ActionStatus.Dispatched) {
                this.dispatched$.next(ctx);
            }
        });
        const destroyRef = inject(DestroyRef);
        destroyRef.onDestroy(() => {
            // Complete the subject once the root injector is destroyed to ensure
            // there are no active subscribers that would receive events or perform
            // any actions after the application is destroyed.
            this.complete();
            this.dispatched$.complete();
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActions, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActions, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
class Actions extends Observable {
    constructor() {
        const internalActions$ = inject(InternalActions);
        const internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);
        // The `InternalActions` subject emits outside of the Angular zone.
        // We have to re-enter the Angular zone for any incoming consumer.
        // The shared `Subject` reduces the number of change detections.
        // This would call leave only once for any stream emission across all active subscribers.
        const sharedInternalActions$ = new Subject();
        internalActions$
            .pipe(leaveNgxs(internalExecutionStrategy))
            .subscribe(sharedInternalActions$);
        super(observer => {
            const childSubscription = sharedInternalActions$.subscribe({
                next: ctx => observer.next(ctx),
                error: error => observer.error(error),
                complete: () => observer.complete()
            });
            observer.add(childSubscription);
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Actions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Actions, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Actions, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

class InternalDispatcher {
    _ngZone = inject(NgZone);
    _actions = inject(InternalActions);
    _actionResults = inject(InternalDispatchedActionResults);
    _pluginManager = inject(PluginManager);
    _stateStream = inject(_StateStream);
    _ngxsExecutionStrategy = inject(InternalNgxsExecutionStrategy);
    _injector = inject(Injector);
    /**
     * Dispatches event(s).
     */
    dispatch(actionOrActions) {
        const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));
        return result.pipe(fallbackSubscriber(this._ngZone), leaveNgxs(this._ngxsExecutionStrategy));
    }
    dispatchByEvents(actionOrActions) {
        if (Array.isArray(actionOrActions)) {
            if (actionOrActions.length === 0)
                return of(undefined);
            return forkJoin(actionOrActions.map(action => this.dispatchSingle(action))).pipe(map(() => undefined));
        }
        else {
            return this.dispatchSingle(actionOrActions);
        }
    }
    dispatchSingle(action) {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            const type = getActionTypeFromInstance(action);
            if (!type) {
                const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);
                return new Observable(subscriber => subscriber.error(error));
            }
        }
        const prevState = this._stateStream.getValue();
        const plugins = this._pluginManager.plugins;
        return compose(this._injector, [
            ...plugins,
            (nextState, nextAction) => {
                if (nextState !== prevState) {
                    this._stateStream.next(nextState);
                }
                const actionResult$ = this.getActionResultStream(nextAction);
                actionResult$.subscribe(ctx => this._actions.next(ctx));
                this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });
                return this.createDispatchObservable(actionResult$);
            }
        ])(prevState, action).pipe(shareReplay());
    }
    getActionResultStream(action) {
        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== ActionStatus.Dispatched), take(1), shareReplay());
    }
    createDispatchObservable(actionResult$) {
        return actionResult$.pipe(mergeMap((ctx) => {
            switch (ctx.status) {
                case ActionStatus.Successful:
                    // The `createDispatchObservable` function should return the
                    // state, as its result is used by plugins.
                    return of(this._stateStream.getValue());
                case ActionStatus.Errored:
                    throw ctx.error;
                default:
                    // Once dispatched or canceled, we complete it immediately because
                    // `dispatch()` should emit (or error, or complete) as soon as it succeeds or fails.
                    return EMPTY;
            }
        }), shareReplay());
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatcher, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalDispatcher, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 */
const compose = (injector, funcs) => (...args) => {
    const curr = funcs.shift();
    return runInInjectionContext(injector, () => curr(...args, (...nextArgs) => compose(injector, funcs)(...nextArgs)));
};

// The injection token is used to resolve a list of states provided at
// the root level through either `NgxsModule.forRoot` or `provideStore`.
const ROOT_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROOT_STATE_TOKEN' : '');
// The injection token is used to resolve a list of states provided at
// the feature level through either `NgxsModule.forFeature` or `provideStates`.
// The Array<Array> is used to overload the resolved value of the token because
// it is a multi-provider token.
const FEATURE_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FEATURE_STATE_TOKEN' : '');
// The injection token is used to resolve to options provided at the root
// level through either `NgxsModule.forRoot` or `provideStore`.
const NGXS_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_OPTIONS' : '');
/**
 * The NGXS config settings.
 */
class NgxsConfig {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the `Object.freeze` will be tree-shaken away.
     */
    developmentMode;
    compatibility = {
        strictContentSecurityPolicy: false
    };
    /**
     * Defining shared selector options
     */
    selectorOptions = {
        injectContainerState: false,
        suppressErrors: false
    };
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsConfig, providedIn: 'root', useFactory: () => {
            const defaultConfig = new NgxsConfig();
            const config = inject(NGXS_OPTIONS);
            return {
                ...defaultConfig,
                ...config,
                selectorOptions: {
                    ...defaultConfig.selectorOptions,
                    ...config.selectorOptions
                }
            };
        } });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useFactory: () => {
                        const defaultConfig = new NgxsConfig();
                        const config = inject(NGXS_OPTIONS);
                        return {
                            ...defaultConfig,
                            ...config,
                            selectorOptions: {
                                ...defaultConfig.selectorOptions,
                                ...config.selectorOptions
                            }
                        };
                    }
                }]
        }] });
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 */
class NgxsSimpleChange {
    previousValue;
    currentValue;
    firstChange;
    constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
    }
}

/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 */
const deepFreeze = (o) => {
    Object.freeze(o);
    const oIsFunction = typeof o === 'function';
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (_hasOwnProperty(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
};

/**
 * @ignore
 */
class InternalStateOperations {
    _stateStream = inject(_StateStream);
    _dispatcher = inject(InternalDispatcher);
    _config = inject(NgxsConfig);
    /**
     * Returns the root state operators.
     */
    getRootStateOperations() {
        const rootStateOperations = {
            getState: () => this._stateStream.getValue(),
            setState: (newState) => this._stateStream.next(newState),
            dispatch: (actionOrActions) => this._dispatcher.dispatch(actionOrActions)
        };
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            return this._config.developmentMode
                ? ensureStateAndActionsAreImmutable(rootStateOperations)
                : rootStateOperations;
        }
        else {
            return rootStateOperations;
        }
    }
    setStateToTheCurrentWithNew(results) {
        const stateOperations = this.getRootStateOperations();
        // Get our current stream
        const currentState = stateOperations.getState();
        // Set the state to the current + new
        stateOperations.setState({ ...currentState, ...results.defaults });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalStateOperations, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalStateOperations, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalStateOperations, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function ensureStateAndActionsAreImmutable(root) {
    return {
        getState: () => root.getState(),
        setState: value => {
            const frozenValue = deepFreeze(value);
            return root.setState(frozenValue);
        },
        dispatch: actions => {
            return root.dispatch(actions);
        }
    };
}

function createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {
    return (context) => {
        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);
        const { suppressErrors } = selectorOptions;
        return function selectFromRoot(rootState) {
            // Determine arguments from the app state using the selectors
            const results = argumentSelectorFunctions.map(argFn => argFn(rootState));
            // If the lambda attempts to access something in the state that doesn't exist,
            // it will throw a `TypeError`. Since this behavior is common, we simply return
            // `undefined` in such cases.
            try {
                return memoizedSelectorFn(...results);
            }
            catch (ex) {
                if (suppressErrors && ex instanceof TypeError) {
                    return undefined;
                }
                // We're logging an error in this function because it may be used by `select`,
                // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch
                // exceptions there to log errors.
                if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                    const message = 'The selector below has thrown an error upon invocation. ' +
                        'Please check for any unsafe property access that may result in null ' +
                        'or undefined values.';
                    // Avoid concatenating the message with the original function, as this will
                    // invoke `toString()` on the function. Instead, log it as the second argument.
                    // This way, developers will be able to navigate to the actual code in the browser.
                    console.error(message, selectorMetaData.originalFn);
                }
                throw ex;
            }
        };
    };
}
function createMemoizedSelectorFn(originalFn, creationMetadata) {
    const containerClass = creationMetadata?.containerClass;
    const wrappedFn = function wrappedSelectorFn() {
        // eslint-disable-next-line prefer-rest-params
        const returnValue = originalFn.apply(containerClass, arguments);
        if (typeof returnValue === 'function') {
            const innerMemoizedFn = _memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    const memoizedFn = _memoize(wrappedFn);
    Object.setPrototypeOf(memoizedFn, originalFn);
    return memoizedFn;
}
function getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {
    const localSelectorOptions = selectorMetaData.getSelectorOptions();
    const selectorOptions = context.getSelectorOptions(localSelectorOptions);
    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);
    const argumentSelectorFunctions = selectorsToApply.map(selector => {
        const factory = getRootSelectorFactory(selector);
        return factory(context);
    });
    return {
        selectorOptions,
        argumentSelectorFunctions
    };
}
function getSelectorsToApply(selectors = [], selectorOptions, containerClass) {
    const selectorsToApply = [];
    // The container state refers to the state class that includes the
    // definition of the selector function, for example:
    // @State()
    // class AnimalsState {
    //   @Selector()
    //   static getAnimals(state: AnimalsStateModel) {}
    // }
    // The `AnimalsState` serves as the container state. Additionally, the
    // selector may reside within a namespace or another class lacking the
    // `@State` decorator, thus not being treated as the container state.
    const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;
    if (containerClass && canInjectContainerState) {
        // If we are on a state class, add it as the first selector parameter
        const metadata = _getStoreMetadata(containerClass);
        if (metadata) {
            selectorsToApply.push(containerClass);
        }
    }
    selectorsToApply.push(...selectors);
    return selectorsToApply;
}
/**
 * This function gets the factory function to create the selector to get the selected slice from the app state
 * @ignore
 */
function getRootSelectorFactory(selector) {
    const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);
    return metadata?.makeRootSelector || (() => selector);
}

/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 */
function compliantPropGetter(paths) {
    return obj => {
        for (let i = 0; i < paths.length; i++) {
            if (!obj)
                return undefined;
            obj = obj[paths[i]];
        }
        return obj;
    };
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 */
function fastPropGetter(paths) {
    const segments = paths;
    let seg = 'store.' + segments[0];
    let i = 0;
    const l = segments.length;
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    const fn = new Function('store', 'return ' + expr + ';');
    return fn;
}
const ɵPROP_GETTER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PROP_GETTER' : '', {
    providedIn: 'root',
    factory: () => inject(NgxsConfig).compatibility?.strictContentSecurityPolicy
        ? compliantPropGetter
        : fastPropGetter
});
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 */
function buildGraph(stateClasses) {
    // Resolve a state's name from the class reference.
    const findName = (stateClass) => {
        const meta = stateClasses.find(s => s === stateClass);
        if (typeof ngDevMode !== 'undefined' && ngDevMode && !meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return meta[_META_KEY].name;
    };
    // Build the dependency graph.
    return stateClasses.reduce((graph, stateClass) => {
        const meta = stateClass[_META_KEY];
        graph[meta.name] = (meta.children || []).map(findName);
        return graph;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 */
function nameToState(states) {
    return states.reduce((result, stateClass) => {
        const meta = stateClass[_META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 */
function findFullParentPath(obj, out = {}) {
    // Recursively find the full dotted parent path for a given key.
    const find = (graph, target) => {
        for (const key in graph) {
            if (graph[key]?.includes(target)) {
                const parent = find(graph, key);
                return parent ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    // Build full path for each key
    for (const key in obj) {
        const parent = find(obj, key);
        out[key] = parent ? `${parent}.${key}` : key;
    }
    return out;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 */
function topologicalSort(graph) {
    const sorted = [];
    const visited = {};
    // DFS (Depth-First Search) to visit each node and its dependencies.
    const visit = (name, ancestors = []) => {
        visited[name] = true;
        ancestors.push(name);
        for (const dep of graph[name]) {
            if (typeof ngDevMode !== 'undefined' && ngDevMode && ancestors.includes(dep)) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (!visited[dep])
                visit(dep, ancestors.slice());
        }
        // Add to sorted list if not already included.
        if (!sorted.includes(name))
            sorted.push(name);
    };
    // Start DFS from each key
    for (const key in graph)
        visit(key);
    return sorted.reverse();
}

function throwStateNameError(name) {
    throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);
}
function throwStateNamePropertyError() {
    throw new Error(`States must register a 'name' property.`);
}
function throwStateUniqueError(current, newName, oldName) {
    throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);
}
function throwStateDecoratorError(name) {
    throw new Error(`States must be decorated with @State() decorator, but "${name}" isn't.`);
}
function throwActionDecoratorError() {
    throw new Error('@Action() decorator cannot be used with static methods.');
}
function throwSelectorDecoratorError() {
    throw new Error('Selectors only work on methods.');
}
function getUndecoratedStateWithInjectableWarningMessage(name) {
    return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;
}
function getInvalidInitializationOrderMessage(addedStates) {
    let message = 'You have an invalid state initialization order. This typically occurs when `NgxsModule.forFeature`\n' +
        'or `provideStates` is called before `NgxsModule.forRoot` or `provideStore`.\n' +
        'One example is when `NgxsRouterPluginModule.forRoot` is called before `NgxsModule.forRoot`.';
    if (addedStates) {
        const stateNames = Object.keys(addedStates).map(stateName => `"${stateName}"`);
        message +=
            '\nFeature states added before the store initialization is complete: ' +
                `${stateNames.join(', ')}.`;
    }
    return message;
}
function throwPatchingArrayError() {
    throw new Error('Patching arrays is not supported.');
}
function throwPatchingPrimitiveError() {
    throw new Error('Patching primitives is not supported.');
}

const stateNameRegex = /* @__PURE__ */ new RegExp('^[a-zA-Z0-9_]+$');
function ensureStateNameIsValid(name) {
    if (!name) {
        throwStateNamePropertyError();
    }
    else if (!stateNameRegex.test(name)) {
        throwStateNameError(name);
    }
}
function ensureStateNameIsUnique(stateName, state, statesByName) {
    const existingState = statesByName[stateName];
    if (existingState && existingState !== state) {
        throwStateUniqueError(stateName, state.name, existingState.name);
    }
}
function ensureStatesAreDecorated(stateClasses) {
    stateClasses.forEach((stateClass) => {
        if (!_getStoreMetadata(stateClass)) {
            throwStateDecoratorError(stateClass.name);
        }
    });
}

/**
 * All provided or injected tokens must have `@Injectable` decorator
 * (previously, injected tokens without `@Injectable` were allowed
 * if another decorator was used, e.g. pipes).
 */
function ensureStateClassIsInjectable(stateClass) {
    if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {
        return;
    }
    console.warn(getUndecoratedStateWithInjectableWarningMessage(stateClass.name));
}
function aot_hasNgInjectableDef(stateClass) {
    // `ɵprov` is a static property added by the NGCC compiler. It always exists in
    // AOT mode because this property is added before runtime. If an application is running in
    // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`
    // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.
    return !!stateClass.ɵprov;
}
function jit_hasInjectableAnnotation(stateClass) {
    // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).
    const annotations = stateClass.__annotations__ || [];
    return annotations.some((annotation) => annotation?.ngMetadataName === 'Injectable');
}

const NGXS_DEVELOPMENT_OPTIONS = 
/* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_DEVELOPMENT_OPTIONS' : '', {
    providedIn: 'root',
    factory: () => ({ warnOnUnhandledActions: true })
});

class NgxsUnhandledActionsLogger {
    /**
     * These actions should be ignored by default; the user can increase this
     * list in the future via the `ignoreActions` method.
     */
    _ignoredActions = new Set([InitState.type, UpdateState.type]);
    constructor() {
        const options = inject(NGXS_DEVELOPMENT_OPTIONS);
        if (typeof options.warnOnUnhandledActions === 'object') {
            this.ignoreActions(...options.warnOnUnhandledActions.ignore);
        }
    }
    /**
     * Adds actions to the internal list of actions that should be ignored.
     */
    ignoreActions(...actions) {
        for (const action of actions) {
            this._ignoredActions.add(action.type);
        }
    }
    /** @internal */
    warn(action) {
        const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));
        if (actionShouldBeIgnored) {
            return;
        }
        action =
            action.constructor && action.constructor.name !== 'Object'
                ? action.constructor.name
                : action.type;
        console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledActionsLogger, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledActionsLogger });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledActionsLogger, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

class NgxsUnhandledErrorHandler {
    _ngZone = inject(NgZone);
    _errorHandler = inject(ErrorHandler);
    /**
     * The `_unhandledErrorContext` is left unused internally since we do not
     * require it for internal operations. However, developers who wish to provide
     * their own custom error handler may utilize this context information.
     */
    handleError(error, _unhandledErrorContext) {
        // In order to avoid duplicate error handling, it is necessary to leave
        // the Angular zone to ensure that errors are not caught twice. The `handleError`
        // method may contain a `throw error` statement, which is used to re-throw the error.
        // If the error is re-thrown within the Angular zone, it will be caught again by the
        // Angular zone. By default, `@angular/core` leaves the Angular zone when invoking
        // `handleError` (see `_callAndReportToErrorHandler`).
        this._ngZone.runOutsideAngular(() => this._errorHandler.handleError(error));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledErrorHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledErrorHandler, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsUnhandledErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 */
function ofAction(...allowedTypes) {
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 */
function ofActionDispatched(...allowedTypes) {
    return ofActionOperator(allowedTypes, [ActionStatus.Dispatched]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 */
function ofActionSuccessful(...allowedTypes) {
    return ofActionOperator(allowedTypes, [ActionStatus.Successful]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 */
function ofActionCanceled(...allowedTypes) {
    return ofActionOperator(allowedTypes, [ActionStatus.Canceled]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been completed
 */
function ofActionCompleted(...allowedTypes) {
    const allowedStatuses = [
        ActionStatus.Successful,
        ActionStatus.Canceled,
        ActionStatus.Errored
    ];
    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 */
function ofActionErrored(...allowedTypes) {
    return ofActionOperator(allowedTypes, [ActionStatus.Errored], mapActionResult);
}
function ofActionOperator(allowedTypes, statuses, 
// This could have been written as
// `OperatorFunction<ActionContext, ActionCompletion | any>`, as it maps
// either to `ctx.action` or to `ActionCompletion`. However,
// `ActionCompletion | any` defaults to `any`, rendering the union
// type meaningless.
mapOperator = mapAction) {
    const allowedMap = createAllowedActionTypesMap(allowedTypes);
    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);
    return function (o) {
        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());
    };
}
function filterStatus(allowedTypes, allowedStatuses) {
    return filter((ctx) => {
        const actionType = getActionTypeFromInstance(ctx.action);
        const typeMatch = allowedTypes[actionType];
        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;
        return typeMatch && statusMatch;
    });
}
function mapActionResult() {
    return map(({ action, status, error }) => {
        return {
            action,
            result: {
                successful: ActionStatus.Successful === status,
                canceled: ActionStatus.Canceled === status,
                error
            }
        };
    });
}
function mapAction() {
    return map((ctx) => ctx.action);
}
function createAllowedActionTypesMap(types) {
    return types.reduce((filterMap, klass) => {
        filterMap[getActionTypeFromInstance(klass)] = true;
        return filterMap;
    }, {});
}
function createAllowedStatusesMap(statuses) {
    return statuses.reduce((filterMap, status) => {
        filterMap[status] = true;
        return filterMap;
    }, {});
}

function simplePatch(value) {
    return (existingState) => {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            if (Array.isArray(value)) {
                throwPatchingArrayError();
            }
            else if (typeof value !== 'object') {
                throwPatchingPrimitiveError();
            }
        }
        const newState = { ...existingState };
        for (const key in value) {
            // deep clone for patch compatibility
            newState[key] = value[key];
        }
        return newState;
    };
}

/**
 * State Context factory class
 * @ignore
 */
class StateContextFactory {
    _internalStateOperations = inject(InternalStateOperations);
    /**
     * Create the state context
     */
    createStateContext(path) {
        const root = this._internalStateOperations.getRootStateOperations();
        return {
            getState() {
                const currentAppState = root.getState();
                return getState(currentAppState, path);
            },
            patchState(val) {
                const currentAppState = root.getState();
                const patchOperator = simplePatch(val);
                setStateFromOperator(root, currentAppState, patchOperator, path);
            },
            setState(val) {
                const currentAppState = root.getState();
                if (isStateOperator(val)) {
                    setStateFromOperator(root, currentAppState, val, path);
                }
                else {
                    setStateValue(root, currentAppState, val, path);
                }
            },
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateContextFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateContextFactory, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateContextFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function setStateValue(root, currentAppState, newValue, path) {
    const newAppState = setValue(currentAppState, path, newValue);
    root.setState(newAppState);
    return newAppState;
    // In doing this refactoring I noticed that there is a 'bug' where the
    // application state is returned instead of this state slice.
    // This has worked this way since the beginning see:
    // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
    // This needs to be fixed, but is a 'breaking' change.
    // I will do this fix in a subsequent PR and we can decide how to handle it.
}
function setStateFromOperator(root, currentAppState, stateOperator, path) {
    const local = getState(currentAppState, path);
    const newValue = stateOperator(local);
    return setStateValue(root, currentAppState, newValue, path);
}
function getState(currentAppState, path) {
    return getValue(currentAppState, path);
}

class InternalActionHandlerFactory {
    _actions = inject(InternalActions);
    _stateContextFactory = inject(StateContextFactory);
    createActionHandler(path, handlerFn, options) {
        const { dispatched$ } = this._actions;
        return (action) => {
            const stateContext = this._stateContextFactory.createStateContext(path);
            let result = handlerFn(stateContext, action);
            // We need to use `isPromise` instead of checking whether
            // `result instanceof Promise`. In zone.js patched environments, `global.Promise`
            // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js
            // for certain reasons, might not work with `instanceof`. For instance, the dynamic
            // import returns a native promise (not a `ZoneAwarePromise`), causing this check to
            // be falsy.
            if (_isPromise(result)) {
                result = from(result);
            }
            if (isObservable(result)) {
                result = result.pipe(mergeMap(value => (_isPromise(value) || isObservable(value) ? value : of(value))), 
                // If this observable has completed without emitting any values,
                // we wouldn't want to complete the entire chain of actions.
                // If any observable completes, then the action will be canceled.
                // For instance, if any action handler had a statement like
                // `handler(ctx) { return EMPTY; }`, then the action would be canceled.
                // See https://github.com/ngxs/store/issues/1568
                // Note that we actually don't care about the return type; we only care
                // about emission, and thus `undefined` is applicable by the framework.
                defaultIfEmpty(undefined));
                if (options.cancelUncompleted) {
                    const canceled = dispatched$.pipe(ofActionDispatched(action));
                    result = result.pipe(takeUntil(canceled));
                }
                result = result.pipe(
                // Note that we use the `finalize` operator only when the action handler
                // explicitly returns an observable (or a promise) to wait for. This means
                // the action handler is written in a "fire & wait" style. If the handler’s
                // result is unsubscribed (either because the observable has completed or
                // it was unsubscribed by `takeUntil` due to a new action being dispatched),
                // we prevent writing to the state context.
                finalize(() => {
                    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                        function noopAndWarn() {
                            console.warn(`"${action}" attempted to change the state, but the change was ignored because state updates are not allowed after the action handler has completed.`);
                        }
                        stateContext.setState = noopAndWarn;
                        stateContext.patchState = noopAndWarn;
                    }
                    else {
                        stateContext.setState = noop;
                        stateContext.patchState = noop;
                    }
                }));
            }
            else {
                // If the action handler is synchronous and returns nothing (`void`), we
                // still have to convert the result to a synchronous observable.
                result = of(undefined);
            }
            return result;
        };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActionHandlerFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActionHandlerFactory, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: InternalActionHandlerFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
// This is used to replace `setState` and `patchState` once the action
// handler has been unsubscribed or completed, to prevent writing
// to the state context.
function noop() { }

function cloneDefaults(defaults) {
    let value = defaults === undefined ? {} : defaults;
    if (defaults) {
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (typeof defaults === 'object') {
            value = { ...defaults };
        }
    }
    return value;
}
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 *
 * Root and feature initializers call `addAndReturnDefaults()` to add those states
 * to the global graph. Since `addAndReturnDefaults` runs within the injection
 * context (which might be the root injector or a feature injector), we can
 * retrieve an instance of the state class using `inject(StateClass)`.
 * @ignore
 */
class StateFactory {
    _injector = inject(Injector);
    _config = inject(NgxsConfig);
    _actionHandlerFactory = inject(InternalActionHandlerFactory);
    _actions = inject(InternalActions);
    _actionResults = inject(InternalDispatchedActionResults);
    _initialState = inject(_INITIAL_STATE_TOKEN, { optional: true });
    _actionRegistry = inject(_NgxsActionRegistry);
    _propGetter = inject(ɵPROP_GETTER);
    _actionsSubscription = null;
    _ngxsUnhandledErrorHandler = null;
    _states = [];
    _statesByName = {};
    _statePaths = {};
    getRuntimeSelectorContext = _memoize(() => {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const stateFactory = this;
        const propGetter = stateFactory._propGetter;
        function resolveGetter(key) {
            const path = stateFactory._statePaths[key];
            return path ? propGetter(path.split('.')) : null;
        }
        const context = {
            getStateGetter(key) {
                // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.
                // This is a Terser annotation, which will function only in the production mode.
                let getter = /*@__INLINE__*/ resolveGetter(key);
                if (getter) {
                    return getter;
                }
                return (...args) => {
                    // Late loaded getter
                    if (!getter) {
                        getter = /*@__INLINE__*/ resolveGetter(key);
                    }
                    return getter ? getter(...args) : undefined;
                };
            },
            getSelectorOptions(localOptions) {
                const globalSelectorOptions = stateFactory._config.selectorOptions;
                return {
                    ...globalSelectorOptions,
                    ...(localOptions || {})
                };
            }
        };
        return context;
    });
    constructor() {
        inject(DestroyRef).onDestroy(() => this._actionsSubscription?.unsubscribe());
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            ensureStatesAreDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[_META_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: inject(stateClass),
                defaults: cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this._states.push(stateMap);
            this.hydrateActionMetasMap(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    connectActionHandlers() {
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === ActionStatus.Dispatched), mergeMap(ctx => {
            const action = ctx.action;
            return this.invokeActions(action).pipe(map(() => ({ action, status: ActionStatus.Successful })), defaultIfEmpty({ action, status: ActionStatus.Canceled }), catchError(error => {
                const ngxsUnhandledErrorHandler = (this._ngxsUnhandledErrorHandler ||=
                    this._injector.get(NgxsUnhandledErrorHandler));
                const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, { action }));
                return of({
                    action,
                    status: ActionStatus.Errored,
                    error: handleableError
                });
            }));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        const actionHandlers = this._actionRegistry.get(type);
        if (actionHandlers) {
            for (const actionHandler of actionHandlers) {
                let result;
                try {
                    result = actionHandler(action);
                }
                catch (e) {
                    result = new Observable(subscriber => subscriber.error(e));
                }
                results.push(result);
                actionHasBeenHandled = true;
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if (typeof ngDevMode !== 'undefined' && ngDevMode && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            unhandledActionsLogger?.warn(action);
        }
        if (!results.length) {
            results.push(of(undefined));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this._statesByName;
        for (const stateClass of stateClasses) {
            const stateName = _getStoreMetadata(stateClass).name;
            if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                ensureStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this._statePaths[meta.name] = path;
        // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins
        meta.path = path;
    }
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        // This checks whether a state has been already added to the global graph and
        // its lifecycle is in 'bootstrapped' state.
        return this._statesByName[name] && valueIsBootstrappedInInitialState;
    }
    hydrateActionMetasMap({ path, actions, instance }) {
        for (const actionType of Object.keys(actions)) {
            const actionHandlers = actions[actionType].map(actionMeta => {
                const handlerFn = (ctx, action) => instance[actionMeta.fn](ctx, action);
                return this._actionHandlerFactory.createActionHandler(path, handlerFn, actionMeta.options);
            });
            for (const actionHandler of actionHandlers) {
                this._actionRegistry.register(actionType, actionHandler);
            }
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateFactory, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

class Store {
    _stateStream = inject(_StateStream);
    _internalStateOperations = inject(InternalStateOperations);
    _config = inject(NgxsConfig);
    _internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);
    _stateFactory = inject(StateFactory);
    /**
     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
     */
    _selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));
    constructor() {
        this.initStateStream();
    }
    /**
     * Dispatches action(s).
     */
    dispatch(actionOrActions) {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            if (
            // If a single action is dispatched and it's nullable.
            actionOrActions == null ||
                // If a list of actions is dispatched and any of the actions are nullable.
                (Array.isArray(actionOrActions) && actionOrActions.some(action => action == null))) {
                const error = new Error('`dispatch()` was called without providing an action.');
                return new Observable(subscriber => subscriber.error(error));
            }
        }
        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);
    }
    /**
     * Selects a slice of data from the store.
     */
    select(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return this._selectableStateStream.pipe(map(selectorFn), catchError((error) => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw error;
        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
    }
    /**
     * Select one slice of data from the store.
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Select a signal from the state.
     */
    selectSignal(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return computed(() => selectorFn(this._stateStream.state()));
    }
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn) {
        return this._selectableStateStream
            .pipe(leaveNgxs(this._internalExecutionStrategy))
            .subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state) {
        this._internalStateOperations.getRootStateOperations().setState(state);
    }
    getStoreBoundSelectorFn(selector) {
        const makeSelectorFn = getRootSelectorFactory(selector);
        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();
        return makeSelectorFn(runtimeContext);
    }
    initStateStream() {
        const initialStateValue = inject(_INITIAL_STATE_TOKEN);
        const value = this._stateStream.value;
        const storeIsEmpty = !value || Object.keys(value).length === 0;
        if (storeIsEmpty) {
            this._stateStream.next(initialStateValue);
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Store, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Store, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: Store, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

/**
 * InjectionToken that registers preboot functions (called before the root initializer).
 */
const NGXS_PREBOOT_FNS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_PREBOOT_FNS' : '');
/**
 * This function registers a preboot function which will be called before the root
 * store initializer is run, but after all of the NGXS features are provided and
 * available for injection. This is useful for registering action stream listeners
 * before any action is dispatched.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPreboot(() => {
 *         const actions$ = inject(Actions);
 *         actions$.subscribe(ctx => console.log(ctx));
 *       })
 *     )
 *   ]
 * });
 * ```
 */
function withNgxsPreboot(prebootFn) {
    return makeEnvironmentProviders([
        { provide: NGXS_PREBOOT_FNS, multi: true, useValue: prebootFn }
    ]);
}

const ROOT_STORE_GUARD = /* @__PURE__ */ new InjectionToken('ROOT_STORE_GUARD', {
    providedIn: 'root',
    factory: () => ({ initialized: false })
});
function assertRootStoreNotInitialized() {
    const rootStoreGuard = inject(ROOT_STORE_GUARD);
    if (rootStoreGuard.initialized) {
        throw new Error('provideStore() should only be called once.');
    }
    rootStoreGuard.initialized = true;
}

/**
 * Allows the select decorator to get access to the DI store, this is used internally
 * in `@Select` decorator.
 */
class SelectFactory {
    static store = null;
    static config = null;
    constructor(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
        inject(DestroyRef).onDestroy(() => {
            SelectFactory.store = null;
            SelectFactory.config = null;
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: SelectFactory, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: SelectFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: Store }, { type: NgxsConfig }] });

class LifecycleStateManager {
    _store = inject(Store);
    _internalStateOperations = inject(InternalStateOperations);
    _stateContextFactory = inject(StateContextFactory);
    _appBootstrappedState = inject(_NgxsAppBootstrappedState);
    _initStateHasBeenDispatched;
    ngxsBootstrap(action, results) {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            if (action instanceof InitState) {
                this._initStateHasBeenDispatched = true;
            }
            else if (
            // This is a dev mode-only check that ensures the correct order of
            // state initialization. The `NgxsModule.forRoot` or `provideStore` should
            // always come first, followed by `forFeature` and `provideStates`. If the
            // `UpdateState` is dispatched before the `InitState` is dispatched, it indicates
            // that modules or providers are in an invalid order.
            action instanceof UpdateState &&
                !this._initStateHasBeenDispatched) {
                console.error(getInvalidInitializationOrderMessage(action.addedStates));
            }
        }
        // It does not need to unsubscribe because it is completed when the
        // root injector is destroyed.
        this._internalStateOperations
            .getRootStateOperations()
            .dispatch(action)
            .pipe(mergeMap(() => {
            // If no states are provided, we safely complete the stream
            // and do not proceed further.
            if (!results) {
                return EMPTY;
            }
            this._invokeInitOnStates(results.states);
            return this._appBootstrappedState;
        }))
            .subscribe(appBootstrapped => {
            if (appBootstrapped) {
                this._invokeBootstrapOnStates(results.states);
            }
        });
    }
    _invokeInitOnStates(mappedStores) {
        for (const mappedStore of mappedStores) {
            const instance = mappedStore.instance;
            if (instance.ngxsOnChanges) {
                // We are manually keeping track of the previous value
                // within the subscribe block in order to drop the `pairwise()` operator.
                let previousValue;
                // It does not need to unsubscribe because it is completed when the
                // root injector is destroyed.
                this._store
                    .select(state => getValue(state, mappedStore.path))
                    .pipe(
                // Ensure initial state is captured
                startWith(undefined), 
                // `skip` is using `filter` internally.
                skip(1))
                    .subscribe(currentValue => {
                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);
                    previousValue = currentValue;
                    instance.ngxsOnChanges(change);
                });
            }
            if (instance.ngxsOnInit) {
                instance.ngxsOnInit(this._getStateContext(mappedStore));
            }
            mappedStore.isInitialised = true;
        }
    }
    _invokeBootstrapOnStates(mappedStores) {
        for (const mappedStore of mappedStores) {
            const instance = mappedStore.instance;
            if (instance.ngxsAfterBootstrap) {
                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));
            }
        }
    }
    _getStateContext(mappedStore) {
        return this._stateContextFactory.createStateContext(mappedStore.path);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: LifecycleStateManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: LifecycleStateManager, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: LifecycleStateManager, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * This function is shared by both NgModule and standalone features.
 * When using `NgxsModule.forRoot` and `provideStore`, we can depend on the
 * same initialization functionality.
 */
function rootStoreInitializer() {
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        assertRootStoreNotInitialized();
    }
    // Override the RxJS `config.onUnhandledError` within the root store initializer,
    // but only after other code has already executed.
    // If users have a custom `config.onUnhandledError`, we might overwrite it too
    // early and capture the original `config.onUnhandledError` before it is properly set.
    installOnUnhandhedErrorHandler();
    const prebootFns = inject(NGXS_PREBOOT_FNS, { optional: true }) || [];
    prebootFns.forEach(prebootFn => prebootFn());
    const factory = inject(StateFactory);
    const internalStateOperations = inject(InternalStateOperations);
    inject(Store);
    inject(SelectFactory);
    const states = inject(ROOT_STATE_TOKEN, { optional: true }) || [];
    const lifecycleStateManager = inject(LifecycleStateManager);
    // Add stores to the state graph and return their defaults.
    const results = factory.addAndReturnDefaults(states);
    internalStateOperations.setStateToTheCurrentWithNew(results);
    // Connect our actions stream.
    factory.connectActionHandlers();
    // Dispatch the init action and invoke init and bootstrap functions after.
    lifecycleStateManager.ngxsBootstrap(new InitState(), results);
}
/**
 * This function is utilized by both NgModule and standalone features.
 * When using `NgxsModule.forFeature` and `provideStates`, we can depend on
 * the same initialization functionality.
 */
function featureStatesInitializer() {
    inject(Store);
    const internalStateOperations = inject(InternalStateOperations);
    const factory = inject(StateFactory);
    const states = inject(FEATURE_STATE_TOKEN, { optional: true }) || [];
    const lifecycleStateManager = inject(LifecycleStateManager);
    // Since FEATURE_STATE_TOKEN is a multi token, we need to
    // flatten it [[Feature1State, Feature2State], [Feature3State]].
    const flattenedStates = states.reduce((total, values) => total.concat(values), []);
    // add stores to the state graph and return their defaults.
    const results = factory.addAndReturnDefaults(flattenedStates);
    if (results.states.length) {
        internalStateOperations.setStateToTheCurrentWithNew(results);
        // Dispatch the update action and invoke init and bootstrap functions after.
        lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);
    }
}
/**
 * InjectionToken that registers the global Store.
 */
const NGXS_ROOT_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_ROOT_STORE_INITIALIZER' : '');
/**
 * InjectionToken that registers feature states.
 */
const NGXS_FEATURE_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_FEATURE_STORE_INITIALIZER' : '');
const NGXS_ROOT_ENVIRONMENT_INITIALIZER = [
    { provide: NGXS_ROOT_STORE_INITIALIZER, useFactory: rootStoreInitializer },
    provideEnvironmentInitializer(() => inject(NGXS_ROOT_STORE_INITIALIZER))
];
/**
 * The `NGXS_FEATURE_ENVIRONMENT_INITIALIZER` functions as an environment initializer
 * at the `Route` level. Angular Router creates an environment route injector for each
 * matched route where navigation occurs. The injector is created once, ensuring that
 * the feature states initialization only happens once as well.
 */
const NGXS_FEATURE_ENVIRONMENT_INITIALIZER = [
    { provide: NGXS_FEATURE_STORE_INITIALIZER, useFactory: featureStatesInitializer },
    provideEnvironmentInitializer(() => inject(NGXS_FEATURE_STORE_INITIALIZER))
];

/**
 * @ignore
 */
class NgxsRootModule {
    constructor() {
        rootStoreInitializer();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsRootModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.3", ngImport: i0, type: NgxsRootModule });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsRootModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsRootModule, decorators: [{
            type: NgModule
        }], ctorParameters: () => [] });

/**
 * @ignore
 */
class NgxsFeatureModule {
    constructor() {
        featureStatesInitializer();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsFeatureModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.3", ngImport: i0, type: NgxsFeatureModule });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsFeatureModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsFeatureModule, decorators: [{
            type: NgModule
        }], ctorParameters: () => [] });

/**
 * This function provides the required providers when invoking `NgxsModule.forRoot`
 * or `provideStore`. It is shared between the NgModule and standalone APIs.
 */
function getRootProviders(states, options) {
    return [
        ...states,
        {
            provide: ROOT_STATE_TOKEN,
            useValue: states
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useFactory: () => {
                const appBootstrappedState = inject(_NgxsAppBootstrappedState);
                return () => appBootstrappedState.bootstrap();
            },
            multi: true
        },
        {
            provide: NGXS_OPTIONS,
            useValue: options
        }
    ];
}

/**
 * This function provides the required providers when calling `NgxsModule.forFeature`
 * or `provideStates`. It is shared between the NgModule and standalone APIs.
 */
function getFeatureProviders(states) {
    return [
        PluginManager,
        ...states,
        {
            provide: FEATURE_STATE_TOKEN,
            multi: true,
            useValue: states
        }
    ];
}

class NgxsModule {
    static forRoot(states = [], options = {}) {
        return {
            ngModule: NgxsRootModule,
            providers: getRootProviders(states, options)
        };
    }
    static forFeature(states = []) {
        return {
            ngModule: NgxsFeatureModule,
            providers: getFeatureProviders(states)
        };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.3", ngImport: i0, type: NgxsModule });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsModule, decorators: [{
            type: NgModule
        }] });

/**
 * Decorates a method with action information.
 */
function Action(actions, options) {
    return (target, name, 
    // This parameter ensures that the decorated method has a call signature that could be passed an instance of the given action(s).
    _descriptor) => {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            const isStaticMethod = _hasOwnProperty(target, 'prototype');
            if (isStaticMethod) {
                throwActionDecoratorError();
            }
        }
        const meta = _ensureStoreMetadata(target.constructor);
        const actionArray = Array.isArray(actions) ? actions : [actions];
        for (const action of actionArray) {
            const type = action.type;
            if (!meta.actions[type]) {
                meta.actions[type] = [];
            }
            meta.actions[type].push({
                fn: name,
                options: options || {},
                type
            });
        }
    };
}

/**
 * Decorates a class with ngxs state information.
 */
function State(options) {
    return (target) => {
        const stateClass = target;
        const inherited = Object.getPrototypeOf(stateClass);
        const meta = _ensureStoreMetadata(stateClass);
        const mergedOptions = { ...(inherited[_META_OPTIONS_KEY] || {}), ...options };
        // Apply merged options to metadata.
        mutateMetaData(meta, inherited, mergedOptions);
        stateClass[_META_OPTIONS_KEY] = mergedOptions;
    };
}
// Updates metadata using inherited and current options
function mutateMetaData(meta, inherited, options) {
    const { name, defaults, children } = options;
    const stateName = typeof name === 'string' ? name : name?.getName?.() || null;
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        ensureStateNameIsValid(stateName);
    }
    if (_hasOwnProperty(inherited, _META_KEY)) {
        const inheritedMeta = inherited[_META_KEY] || {};
        meta.actions = { ...meta.actions, ...inheritedMeta.actions };
    }
    meta.name = stateName;
    meta.defaults = defaults;
    meta.children = children;
}

/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 *
 * Marked for removal. It's only used within `createSelectorFn`.
 */
function propGetter(paths, config) {
    if (config?.compatibility?.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
function throwSelectFactoryNotConnectedError() {
    throw new Error('You have forgotten to import the NGXS module!');
}
const DOLLAR_CHAR_CODE = 36;
function createSelectObservable(selector) {
    if (!SelectFactory.store) {
        throwSelectFactoryNotConnectedError();
    }
    return SelectFactory.store.select(selector);
}
function createSelectorFn(name, rawSelector, paths = []) {
    rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;
    if (typeof rawSelector === 'string') {
        const propsArray = paths.length
            ? [rawSelector, ...paths]
            : rawSelector.split('.');
        return propGetter(propsArray, SelectFactory.config);
    }
    return rawSelector;
}
/**
 * @example If `foo$` => make it just `foo`
 */
function removeDollarAtTheEnd(name) {
    const lastCharIndex = name.length - 1;
    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}

/**
 * Decorator for selecting a slice of state from the store.
 *
 * @deprecated
 * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.
 */
function Select(rawSelector, ...paths) {
    return function (target, key) {
        const name = key.toString();
        const selectorId = `__${name}__selector`;
        const selector = createSelectorFn(name, rawSelector, paths);
        Object.defineProperties(target, {
            [selectorId]: {
                writable: true,
                enumerable: false,
                configurable: true
            },
            [name]: {
                enumerable: true,
                configurable: true,
                get() {
                    return this[selectorId] || (this[selectorId] = createSelectObservable(selector));
                }
            }
        });
    };
}

const SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';
const selectorOptionsMetaAccessor = {
    getOptions: (target) => {
        return target?.[SELECTOR_OPTIONS_META_KEY] || {};
    },
    defineOptions: (target, options) => {
        if (!target)
            return;
        target[SELECTOR_OPTIONS_META_KEY] = options;
    }
};
function setupSelectorMetadata(originalFn, creationMetadata) {
    const selectorMetaData = _ensureSelectorMetadata(originalFn);
    selectorMetaData.originalFn = originalFn;
    let getExplicitSelectorOptions = () => ({});
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName || null;
        getExplicitSelectorOptions =
            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;
    }
    const selectorMetaDataClone = { ...selectorMetaData };
    selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());
    return selectorMetaData;
}
function getLocalSelectorOptions(selectorMetaData, explicitOptions) {
    return {
        ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}),
        ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}),
        ...(selectorMetaData.getSelectorOptions() || {}),
        ...explicitOptions
    };
}

/**
 * Decorator for setting selector options at a method or class level.
 */
function SelectorOptions(options) {
    return (function decorate(target, methodName, descriptor) {
        if (methodName) {
            descriptor ||= Object.getOwnPropertyDescriptor(target, methodName);
            // Method Decorator
            const originalFn = descriptor.value || descriptor.originalFn;
            if (originalFn) {
                selectorOptionsMetaAccessor.defineOptions(originalFn, options);
            }
        }
        else {
            // Class Decorator
            selectorOptionsMetaAccessor.defineOptions(target, options);
        }
    });
}

function createSelector(selectors, projector, creationMetadata) {
    const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);
    const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);
    selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);
    return memoizedFn;
}

function Selector(selectors) {
    return (target, key, descriptor) => {
        descriptor ||= Object.getOwnPropertyDescriptor(target, key);
        const originalFn = descriptor?.value;
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            if (typeof originalFn !== 'function') {
                throwSelectorDecoratorError();
            }
        }
        const memoizedFn = createSelector(selectors, originalFn, {
            containerClass: target,
            selectorName: key.toString(),
            getSelectorOptions() {
                return {};
            }
        });
        const newDescriptor = {
            configurable: true,
            get() {
                return memoizedFn;
            },
            originalFn
        };
        return newDescriptor;
    };
}

class ActionDirector {
    _registry = inject(_NgxsActionRegistry);
    _actionHandlerFactory = inject(InternalActionHandlerFactory);
    attachAction(stateToken, Action, handlerFn, options = {}) {
        const actionHandler = this._actionHandlerFactory.createActionHandler(stateToken.getName(), handlerFn, options);
        const detach = this._registry.register(Action.type, actionHandler);
        return { detach };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: ActionDirector, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: ActionDirector, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: ActionDirector, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class NgxsDevelopmentModule {
    static forRoot(options) {
        return {
            ngModule: NgxsDevelopmentModule,
            providers: [
                NgxsUnhandledActionsLogger,
                { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }
            ]
        };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsDevelopmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.3", ngImport: i0, type: NgxsDevelopmentModule });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsDevelopmentModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxsDevelopmentModule, decorators: [{
            type: NgModule
        }] });
function withNgxsDevelopmentOptions(options) {
    return makeEnvironmentProviders([
        NgxsUnhandledActionsLogger,
        { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }
    ]);
}

function getMissingMetaDataError(selector, context = {}) {
    const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);
    if (!metadata) {
        return new Error(`${context.prefix}The value provided as the ${context.noun} is not a valid selector.`);
    }
    return null;
}
function ensureValidSelector(selector, context = {}) {
    const noun = context.noun || 'selector';
    const prefix = context.prefix ? context.prefix + ': ' : '';
    ensureValueProvided(selector, { noun, prefix: context.prefix });
    const error = getMissingMetaDataError(selector, { noun, prefix });
    if (error) {
        // If we have used this utility within a state class, we may be
        //  before the @State or @Selector decorators have been applied.
        //  wait until the next microtask to verify.
        // Theoretically this situation is only encountered when the javascript
        //  files are being loaded and we are outside the angular zone.
        if (!NgZone.isInAngularZone()) {
            Promise.resolve().then(() => {
                const errorAgain = getMissingMetaDataError(selector, { noun, prefix });
                if (errorAgain) {
                    // Throw the originally captured error so that the stack trace shows the
                    // original utility call site.
                    console.error(error);
                }
            });
        }
        else {
            throw error;
        }
    }
}
function ensureValueProvided(value, context = {}) {
    const noun = context.noun || 'value';
    const prefix = context.prefix ? context.prefix + ': ' : '';
    if (!value) {
        throw new Error(`${prefix}A ${noun} must be provided.`);
    }
}

function createModelSelector(selectorMap) {
    const selectorKeys = Object.keys(selectorMap);
    const selectors = Object.values(selectorMap);
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        ensureValidSelectorMap({
            prefix: '[createModelSelector]',
            selectorMap,
            selectorKeys,
            selectors
        });
    }
    return createSelector(selectors, (...args) => {
        return selectorKeys.reduce((obj, key, index) => {
            obj[key] = args[index];
            return obj;
        }, {});
    });
}
function ensureValidSelectorMap({ prefix, selectorMap, selectorKeys, selectors }) {
    ensureValueProvided(selectorMap, { prefix, noun: 'selector map' });
    ensureValueProvided(typeof selectorMap === 'object', { prefix, noun: 'valid selector map' });
    ensureValueProvided(selectorKeys.length, { prefix, noun: 'non-empty selector map' });
    selectors.forEach((selector, index) => ensureValidSelector(selector, {
        prefix,
        noun: `selector for the '${selectorKeys[index]}' property`
    }));
}

function createPickSelector(selector, keys) {
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        ensureValidSelector(selector, { prefix: '[createPickSelector]' });
    }
    const validKeys = keys.filter(Boolean);
    const selectors = validKeys.map(key => createSelector([selector], (s) => s[key]));
    return createSelector([...selectors], (...props) => {
        return validKeys.reduce((acc, key, index) => {
            acc[key] = props[index];
            return acc;
        }, {});
    });
}

function createPropertySelectors(parentSelector) {
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        ensureValidSelector(parentSelector, {
            prefix: '[createPropertySelectors]',
            noun: 'parent selector'
        });
    }
    const cache = {};
    return new Proxy({}, {
        get(_target, prop) {
            const selector = cache[prop] ||
                createSelector([parentSelector], (s) => s?.[prop]);
            cache[prop] = selector;
            return selector;
        }
    });
}

/**
 * This feature that contributes to app stability, which is required during
 * server-side rendering. With asynchronous actions being dispatched and handled,
 * Angular is unaware of them in zoneless mode and doesn't know whether the app is
 * still unstable. This may prematurely serialize the final HTML that is sent to the client.
 * Including `withNgxsPendingTasks` in your `provideStore` for your SSR
 * app will resolve the above issue.
 */
function withNgxsPendingTasks() {
    return withNgxsPreboot(() => {
        const actions$ = inject(Actions);
        const appRef = inject(ApplicationRef);
        const pendingTasks = inject(PendingTasks);
        // Removing a pending task via the public API forces a scheduled tick, ensuring that
        // stability is async and delayed until there was at least an opportunity to run
        // app synchronization.
        // Adding a new task every time an action is dispatched drastically increases the
        // number of change detection cycles because removing a task schedules a new change
        // detection cycle.
        // If 10 actions are dispatched with synchronous action handlers, this would trigger
        // 10 change detection cycles in a row, potentially leading to an
        // `INFINITE_CHANGE_DETECTION` error.
        let removeTask = null;
        const executedActions = new Set();
        // If the app is forcely destroyed before all actions are completed,
        // we clean up the set of actions being executed to prevent memory leaks
        // and remove the pending task to stabilize the app.
        appRef.onDestroy(() => executedActions.clear());
        let isStable = false;
        appRef.whenStable().then(() => {
            isStable = true;
        });
        const subscription = actions$
            .pipe(filter(context => {
            if (context.status === ActionStatus.Dispatched) {
                executedActions.add(context.action);
                removeTask ||= pendingTasks.add();
                return false;
            }
            else {
                return true;
            }
        }), 
        // Every time an action is completed, we debounce the stream to ensure only one
        // task is removed, even if multiple synchronous actions are completed in a row.
        // We use `buffer` to collect action contexts because, if we only use
        // `debounceTime(0)`, we may lose action contexts that are never removed from the set.
        buffer(actions$.pipe(debounceTime(0))))
            .subscribe(contexts => {
            for (const context of contexts) {
                if (!executedActions.has(context.action)) {
                    continue;
                }
                executedActions.delete(context.action);
                // Mark app as stable once all of the debounced actions have completed.
                if (executedActions.size === 0) {
                    removeTask?.();
                    removeTask = null;
                    if (isStable) {
                        // Stop contributing to stability once the application has become stable,
                        // which may happen on the server before the platform is destroyed or in
                        // the browser once hydration is complete.
                        subscription.unsubscribe();
                    }
                }
            }
        });
    });
}

function provideStore(states = [], ...optionsAndFeatures) {
    const features = [];
    // Options are empty by default (see `forRoot`).
    let options = {};
    if (optionsAndFeatures.length > 0) {
        if (isEnvironmentProvider(optionsAndFeatures[0])) {
            features.push(...optionsAndFeatures);
        }
        else {
            options = optionsAndFeatures[0];
            features.push(...optionsAndFeatures.slice(1));
        }
    }
    return makeEnvironmentProviders([
        ...getRootProviders(states, options),
        NGXS_ROOT_ENVIRONMENT_INITIALIZER,
        features
    ]);
}
function isEnvironmentProvider(target) {
    return !!target.ɵproviders;
}

/**
 * This version serves as a standalone alternative to `NgxsModule.forFeature`.
 * It can be used in a similar manner to register feature states, but at the
 * `Route` providers level:
 *
 * ```ts
 * const routes: Routes = [
 *   {
 *     path: 'products',
 *     loadComponent: async () => {...},
 *     providers: [provideStates([ProductsState])]
 *   }
 * ];
 * ```
 *
 * To lazy-load feature states at the route level,
 * please refer to the `lazyProvider` utility function.
 */
function provideStates(states, ...features) {
    return makeEnvironmentProviders([
        ...getFeatureProviders(states),
        features,
        NGXS_FEATURE_ENVIRONMENT_INITIALIZER
    ]);
}

/**
 * This function registers a custom global plugin for the state.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPlugin(LogoutPlugin)
 *     )
 *   ]
 * });
 * ```
 */
function withNgxsPlugin(plugin) {
    return makeEnvironmentProviders([
        _isPluginClass(plugin)
            ? { provide: NGXS_PLUGINS, useClass: plugin, multi: true }
            : { provide: NGXS_PLUGINS, useValue: plugin, multi: true },
        // We should inject the `PluginManager` to retrieve `NGXS_PLUGINS` and
        // register those plugins. The plugin can be added from inside the child
        // route, so the plugin manager should be re-injected.
        provideEnvironmentInitializer(() => inject(PluginManager))
    ]);
}

/**
 * This function serves as a utility and has multiple purposes.
 * Firstly, it allows you to select properties from the state class
 * without having to inject the store class and use `this.store.selectSignal`,
 * resulting in a more concise implementation. Secondly, it can be used with
 * other solutions such as NgRx signal store with its `signalStoreFeature` or
 * `withComputed` functionalities.
 *
 * Please note that it's named `select` instead of `selectSignal` because
 * signals are evolving into first-class primitives in Angular, displacing other
 * primitives such as observables. Observables represent a stream of events,
 * whereas signals represent a single value changing over time.
 */
function select(selector) {
    return inject(Store).selectSignal(selector);
}

function dispatch(ActionType) {
    const store = inject(Store);
    return (...args) => store.dispatch(new ActionType(...args));
}

function createSelectMap(selectorMap) {
    const store = inject(Store);
    return Object.entries(selectorMap).reduce((accumulator, [key, selector]) => {
        accumulator[key] = store.selectSignal(selector);
        return accumulator;
    }, {});
}

function createDispatchMap(actionMap) {
    return Object.entries(actionMap).reduce((accumulator, [key, ActionType]) => {
        accumulator[key] = dispatch(ActionType);
        return accumulator;
    }, {});
}

function isWrappedDefaultExport(value) {
    return value && typeof value === 'object' && 'default' in value;
}
function maybeUnwrapDefaultExport(input) {
    return isWrappedDefaultExport(input) ? input['default'] : input;
}
const REGISTERED_PROVIDERS = new InjectionToken('', {
    providedIn: 'root',
    factory: () => {
        const registeredProviders = new Set();
        inject(ApplicationRef).onDestroy(() => registeredProviders.clear());
        return registeredProviders;
    }
});
/**
 * This function serves as a utility to lazy-load providers at the injection
 * context level — for example, at the route level. If the feature state needs
 * to be provided in more than one place, it might be indirectly included in
 * the main bundle, which we want to avoid. This function can be used at the
 * guard level to lazy-load the state provider before resolvers run and the
 * component is initialized:
 *
 * ```ts
 * const routes = [
 *   {
 *     path: 'home',
 *     loadComponent: () => import(...),
 *     canActivate: [
 *       lazyProvider(async () => (await import('path-to-state-library')).invoicesStateProvider)
 *     ]
 *   }
 * ];
 * ```
 *
 * Where `invoicesStateProvider` is the following:
 *
 * ```ts
 * // path-to-state-library/index.ts
 *
 * export const invoicesStateProvider = provideStates([InvoicesState]);
 * ```
 */
function lazyProvider(factory) {
    return async () => {
        if (typeof ngDevMode !== 'undefined' && ngDevMode) {
            assertInInjectionContext(lazyProvider);
        }
        const appRef = inject(ApplicationRef);
        const parentInjector = inject(EnvironmentInjector);
        const registeredProviders = inject(REGISTERED_PROVIDERS);
        const provider = maybeUnwrapDefaultExport(await factory());
        if (registeredProviders.has(provider)) {
            return true;
        }
        registeredProviders.add(provider);
        const injector = createEnvironmentInjector([provider], parentInjector);
        appRef.onDestroy(() => injector.destroy());
        return true;
    };
}

// Backward compatibility is provided because these tokens are used by third-party
// libraries. We expose a separate function to allow tree-shaking of these tokens
// if they are not used in standard applications that do not rely on them.
function ɵprovideNgxsInternalStateTokens() {
    return makeEnvironmentProviders([
        {
            provide: _NGXS_STATE_CONTEXT_FACTORY,
            useExisting: StateContextFactory
        },
        {
            provide: _NGXS_STATE_FACTORY,
            useExisting: StateFactory
        }
    ]);
}

/**
 * The public api for consumers of @ngxs/store
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Action, ActionDirector, ActionStatus, Actions, NgxsConfig, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NgxsUnhandledErrorHandler, Select, Selector, SelectorOptions, State, Store, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, lazyProvider, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPendingTasks, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule, ɵprovideNgxsInternalStateTokens };
//# sourceMappingURL=ngxs-store.mjs.map
