import * as i0 from '@angular/core';
import { ModuleWithProviders, Signal, EnvironmentProviders, Type } from '@angular/core';
import { ɵActionOptions as _ActionOptions, StateToken, ɵSharedSelectorOptions as _SharedSelectorOptions, ɵStateClass as _StateClass, ɵStoreOptions as _StoreOptions } from '@ngxs/store/internals';
export { ɵActionOptions as ActionOptions, StateToken } from '@ngxs/store/internals';
import * as rxjs from 'rxjs';
import { Observable, Subscription, OperatorFunction } from 'rxjs';
import { StateOperator } from '@ngxs/store/operators';
export { StateOperator } from '@ngxs/store/operators';
import { NgxsPlugin, NgxsPluginFn } from '@ngxs/store/plugins';
export { InitState, NGXS_PLUGINS, NgxsNextPluginFn, NgxsPlugin, NgxsPluginFn, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';

/**
 * The NGXS config settings.
 */
declare class NgxsConfig {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the `Object.freeze` will be tree-shaken away.
     */
    developmentMode: boolean;
    compatibility: {
        /**
         * Support a strict Content Security Policy.
         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.
         * (default: false)
         */
        strictContentSecurityPolicy: boolean;
    };
    /**
     * Defining shared selector options
     */
    selectorOptions: _SharedSelectorOptions;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsConfig, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsConfig>;
}

/**
 * State context provided to the actions in the state.
 */
interface StateContext<T> {
    /**
     * Get the current state.
     */
    getState(): T;
    /**
     * Reset the state to a new value.
     */
    setState(val: T | StateOperator<T>): void;
    /**
     * Patch the existing state with the provided value.
     */
    patchState(val: Partial<T>): void;
    /**
     * Dispatch a new action and return the dispatched observable.
     */
    dispatch(actions: any | any[]): Observable<void>;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 */
declare class NgxsSimpleChange<T = any> {
    readonly previousValue: T;
    readonly currentValue: T;
    readonly firstChange: boolean;
    constructor(previousValue: T, currentValue: T, firstChange: boolean);
}
/**
 * On init interface
 */
interface NgxsOnInit {
    ngxsOnInit(ctx: StateContext<any>): void;
}
/**
 * On change interface
 */
interface NgxsOnChanges {
    ngxsOnChanges(change: NgxsSimpleChange): void;
}
/**
 * After bootstrap interface
 */
interface NgxsAfterBootstrap {
    ngxsAfterBootstrap(ctx: StateContext<any>): void;
}
type NgxsModuleOptions = Partial<NgxsConfig>;

/**
 * @ignore
 */
declare class NgxsRootModule {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsRootModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsRootModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsRootModule>;
}

/**
 * @ignore
 */
declare class NgxsFeatureModule {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsFeatureModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsFeatureModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsFeatureModule>;
}

declare class NgxsModule {
    static forRoot(states?: _StateClass[], options?: NgxsModuleOptions): ModuleWithProviders<NgxsRootModule>;
    static forFeature(states?: _StateClass[]): ModuleWithProviders<NgxsFeatureModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsModule>;
}

interface ActionDef<TArgs extends any[] = any[], TReturn = any> {
    type: string;
    new (...args: TArgs): TReturn;
}
type ActionType = ActionDef | {
    type: string;
};

/**
 * Given an action class, returns its payload.
 */
type ActionToPayload<Action extends ActionType> = Action extends ActionDef<any, infer ActionPayload> ? ActionPayload : never;
/**
 * Given a list of action classes, returns the union of their payloads.
 */
type ActionsToPayload<Actions extends readonly ActionType[]> = {
    [K in keyof Actions]: ActionToPayload<Actions[K]>;
}[number];
/**
 * Given an action class or a list of action classes, returns the union of their payloads.
 */
type ActionOrActionsToPayload<ActionOrActions> = ActionOrActions extends ActionType ? ActionToPayload<ActionOrActions> : ActionOrActions extends ActionType[] ? ActionsToPayload<ActionOrActions> : never;
/**
 * Describes what methods can be decorated with an `@Action` decorator that has been passed the given action(s).
 */
type HandlerTypedPropertyDescriptor<ActionOrActions> = TypedPropertyDescriptor<() => any> | TypedPropertyDescriptor<(stateContext: StateContext<any>) => any> | TypedPropertyDescriptor<(stateContext: StateContext<any>, action: ActionOrActionsToPayload<ActionOrActions>) => any>;
/**
 * The result of a call to the `@Action()` decorator with the given action(s) as its first argument.
 */
type ActionDecorator<ActionOrActions extends ActionType | ActionType[]> = (target: any, name: string | symbol, _descriptor: HandlerTypedPropertyDescriptor<ActionOrActions>) => void;
/**
 * Decorates a method with action information.
 */
declare function Action<ActionOrActions extends ActionType | ActionType[]>(actions: ActionOrActions, options?: _ActionOptions): ActionDecorator<ActionOrActions>;

type ɵSelectorFunc<TModel> = (...arg: any[]) => TModel;
type TypedSelector<TModel> = StateToken<TModel> | ɵSelectorFunc<TModel>;
type ɵStateSelector = _StateClass<any>;
type ɵSelectorDef<TModel> = ɵStateSelector | TypedSelector<TModel>;
type ɵSelectorReturnType<T extends ɵSelectorDef<any>> = T extends StateToken<infer R1> ? R1 : T extends ɵSelectorFunc<infer R2> ? R2 : T extends _StateClass<any> ? any : never;

interface SelectorMap$1 {
    [key: string]: TypedSelector<any>;
}
type ModelSelector<T extends SelectorMap$1> = (...args: any[]) => MappedResult<T>;
type MappedResult<TSelectorMap> = {
    [P in keyof TSelectorMap]: TSelectorMap[P] extends TypedSelector<infer R> ? R : never;
};
declare function createModelSelector<T extends SelectorMap$1>(selectorMap: T): ModelSelector<T>;

type KeysToValues<T, Keys extends (keyof T)[]> = {
    [Index in keyof Keys]: Keys[Index] extends keyof T ? T[Keys[Index]] : never;
};
declare function createPickSelector<TModel, Keys extends (keyof TModel)[]>(selector: TypedSelector<TModel>, keys: [...Keys]): (...props: KeysToValues<TModel, Keys>) => Pick<TModel, Keys[number]>;

type PropertySelectors<TModel> = {
    [P in keyof NonNullable<TModel>]-?: (model: TModel) => TModel extends null | undefined ? undefined : NonNullable<TModel>[P];
};
declare function createPropertySelectors<TModel>(parentSelector: ɵSelectorDef<TModel>): PropertySelectors<TModel>;

interface CreationMetadata {
    containerClass: any;
    selectorName: string;
    getSelectorOptions?: () => _SharedSelectorOptions;
}

type SelectorArg = ɵSelectorDef<any>;
/**
 * Function for creating a selector
 * @param selectors The selectors to use to create the arguments of this function
 * @param originalFn The original function being made into a selector
 * @param creationMetadata
 */
declare function createSelector<S1 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>) => any>(selectors: [S1], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>) => any>(selectors: [S1, S2], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>) => any>(selectors: [S1, S2, S3], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>) => any>(selectors: [S1, S2, S3, S4], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>) => any>(selectors: [S1, S2, S3, S4, S5], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>) => any>(selectors: [S1, S2, S3, S4, S5, S6], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, S7 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>, s7: ɵSelectorReturnType<S7>) => any>(selectors: [S1, S2, S3, S4, S5, S6, S7], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, S7 extends SelectorArg, S8 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>, s7: ɵSelectorReturnType<S7>, s8: ɵSelectorReturnType<S8>) => any>(selectors: [S1, S2, S3, S4, S5, S6, S7, S8], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<T extends (...args: any[]) => any>(selectors: SelectorArg[] | undefined, projector: T, creationMetadata?: Partial<CreationMetadata>): T;

type ActionOrArrayOfActions<T> = T extends (infer U)[] ? NonNullable<U>[] : NonNullable<T>;
declare class Store {
    private _stateStream;
    private _internalStateOperations;
    private _config;
    private _internalExecutionStrategy;
    private _stateFactory;
    /**
     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
     */
    private _selectableStateStream;
    constructor();
    /**
     * Dispatches action(s).
     */
    dispatch<T>(actionOrActions: ActionOrArrayOfActions<T>): Observable<void>;
    /**
     * Selects a slice of data from the store.
     */
    select<T>(selector: TypedSelector<T>): Observable<T>;
    /**
     * Select one slice of data from the store.
     */
    selectOnce<T>(selector: TypedSelector<T>): Observable<T>;
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot<T>(selector: TypedSelector<T>): T;
    /**
     * Select a signal from the state.
     */
    selectSignal<T>(selector: TypedSelector<T>): Signal<T>;
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn?: (value: any) => void): Subscription;
    /**
     * Return the raw value of the state.
     */
    snapshot(): any;
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state: any): void;
    private getStoreBoundSelectorFn;
    private initStateStream;
    static ɵfac: i0.ɵɵFactoryDeclaration<Store, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Store>;
}

/**
 * Decorates a class with ngxs state information.
 */
declare function State<T>(options: _StoreOptions<T>): (target: _StateClass) => void;

/**
 * Decorator for selecting a slice of state from the store.
 *
 * @deprecated
 * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.
 */
declare function Select<T>(rawSelector?: T, ...paths: string[]): PropertyDecorator;

/**
 * Decorator for setting selector options at a method or class level.
 */
declare function SelectorOptions(options: _SharedSelectorOptions): ClassDecorator & MethodDecorator;

/**
 * Status of a dispatched action
 */
declare enum ActionStatus {
    Dispatched = "DISPATCHED",
    Successful = "SUCCESSFUL",
    Canceled = "CANCELED",
    Errored = "ERRORED"
}
interface ActionContext<T = any> {
    status: ActionStatus;
    action: T;
    error?: Error;
}
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
declare class Actions extends Observable<ActionContext> {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<Actions, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Actions>;
}

type TupleKeys<T extends any[]> = Exclude<keyof T, keyof []>;
/**
 * Given a POJO, returns the POJO type, given a class constructor object, returns the type of the class.
 *
 * This utility type exists due to the complexity of ActionType being either an ActionDef class or the plain
 * `{ type: string }` type (or similar compatible POJO types).
 */
type Constructed<T> = T extends new (...args: any[]) => infer U ? U : T;
interface ActionCompletion<T = any, E = Error> {
    action: T;
    result: {
        successful: boolean;
        canceled: boolean;
        error?: E;
    };
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 */
declare function ofAction<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 */
declare function ofActionDispatched<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 */
declare function ofActionSuccessful<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 */
declare function ofActionCanceled<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been completed
 */
declare function ofActionCompleted<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, ActionCompletion<Constructed<T[TupleKeys<T>]>>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 */
declare function ofActionErrored<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, ActionCompletion<Constructed<T[TupleKeys<T>]>>>;

/**
 * Defines a tuple of selector functions, state tokens, and state classes that a selector decorated
 * by `@Selector()` can depend on.
 */
type SelectorDefTuple = ɵSelectorDef<any>[] | [ɵSelectorDef<any>];
type UnknownToAny<T> = unknown extends T ? any : T;
type EnsureArray<T> = T extends any[] ? T : never;
/**
 * Given a tuple of selector functions, state tokens, state classes, etc., returns a tuple of what
 * a dependent selector would expect to receive for that parent as an argument when called.
 *
 * For example, if the first element in `ParentsTuple` is a selector function that returns a
 * `number`, then the first element of the result tuple will be `number`. If the second element
 * in `ParentsTuple` is a state class with model `{ name: string }`, then the second element of
 * the result tuple will be `{ name: string }`.
 */
type SelectorReturnTypeList<ParentsTuple extends SelectorDefTuple> = EnsureArray<{
    [ParentsTupleIndex in keyof ParentsTuple]: ParentsTuple[ParentsTupleIndex] extends ɵSelectorDef<any> ? UnknownToAny<ɵSelectorReturnType<ParentsTuple[ParentsTupleIndex]>> : never;
}>;
/**
 * Defines a selector function matching a given argument list of parent selectors/states/tokens
 * and a given return type.
 */
type SelectorSpec<ParentsTuple, Return> = ParentsTuple extends [] ? () => any : ParentsTuple extends SelectorDefTuple ? (...states: SelectorReturnTypeList<ParentsTuple>) => Return : () => any;
/**
 * Defines a selector function matching `SelectorSpec<ParentsTuple, Return>` but with the assumption that the
 * container state has been injected as the first argument.
 */
type SelectorSpecWithInjectedState<ParentsTuple, Return> = SelectorSpec<ParentsTuple extends SelectorDefTuple ? [any, ...ParentsTuple] : [any], ParentsTuple extends SelectorDefTuple ? Return : any>;
/**
 * Defines a property descriptor for the `@Selector` decorator that decorates a function with
 * parent selectors/states/tokens `ParentsTuple` and return type `Return`.
 */
type DescriptorWithNoInjectedState<ParentsTuple, Return> = TypedPropertyDescriptor<SelectorSpec<ParentsTuple, Return>>;
/**
 * Same as `DescriptorWithNoInjectedState` but with state injected as the first argument.
 */
type DescriptorWithInjectedState<ParentsTuple, Return> = TypedPropertyDescriptor<SelectorSpecWithInjectedState<ParentsTuple, Return>>;
type DecoratorArgs<Descriptor> = [target: any, key: string | symbol, descriptor?: Descriptor];
/**
 * Defines the return type of a call to `@Selector` when there is no argument given
 * (e.g. `@Selector()` counts, but `@Selector([])` does not)
 *
 * This result is a decorator that can only be used to decorate a function with no arguments or a
 * single argument that is the container state.
 */
type SelectorTypeNoDecoratorArgs = {
    <Return>(...args: DecoratorArgs<DescriptorWithNoInjectedState<unknown, Return>>): void | DescriptorWithNoInjectedState<unknown, Return>;
    <Return>(...args: DecoratorArgs<DescriptorWithInjectedState<unknown, Return>>): void | DescriptorWithInjectedState<unknown, Return>;
};
/**
 * Defines the return type of a call to `@Selector` when there is an argument given.
 * (e.g. `@Selector([])` counts, but `@Selector()` does not)
 *
 * This result is a decorator that can only be used to decorate a function with an argument list
 * matching the results of the tuple of parents `ParentsTuple`.
 */
type SelectorTypeWithDecoratorArgs<ParentsTuple> = {
    <Return>(...args: DecoratorArgs<DescriptorWithNoInjectedState<ParentsTuple, Return>>): void | DescriptorWithNoInjectedState<ParentsTuple, Return>;
    /**
     * @deprecated
     * Read the deprecation notice at this link: https://ngxs.io/deprecations/inject-container-state-deprecation.md.
     */
    <Return>(...args: DecoratorArgs<DescriptorWithInjectedState<ParentsTuple, Return>>): void | DescriptorWithInjectedState<ParentsTuple, Return>;
};
/**
 * Defines the return type of a call to `@Selector`. This result is a decorator that can only be
 * used to decorate a function with an argument list matching `ParentsTuple`, the results of the
 * tuple of parent selectors/state tokens/state classes.
 */
type SelectorType<ParentsTuple> = unknown extends ParentsTuple ? SelectorTypeNoDecoratorArgs : SelectorTypeWithDecoratorArgs<ParentsTuple>;

/**
 * Decorator for creating a state selector for the current state.
 */
declare function Selector(): SelectorType<unknown>;
/**
 * Decorator for creating a state selector from the provided selectors (and optionally the container State, depending on the applicable Selector Options).
 */
declare function Selector<T extends SelectorDefTuple>(selectors: T): SelectorType<T>;

declare class ActionDirector {
    private _registry;
    private _actionHandlerFactory;
    attachAction<TStateModel, TActionType extends ActionDef>(stateToken: StateToken<TStateModel>, Action: TActionType, handlerFn: (ctx: StateContext<TStateModel>, action: InstanceType<TActionType>) => void | Observable<void> | Promise<void>, options?: _ActionOptions): {
        detach: () => void;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<ActionDirector, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ActionDirector>;
}

interface NgxsUnhandledErrorContext {
    action: any;
}
declare class NgxsUnhandledErrorHandler {
    private _ngZone;
    private _errorHandler;
    /**
     * The `_unhandledErrorContext` is left unused internally since we do not
     * require it for internal operations. However, developers who wish to provide
     * their own custom error handler may utilize this context information.
     */
    handleError(error: any, _unhandledErrorContext: NgxsUnhandledErrorContext): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsUnhandledErrorHandler, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsUnhandledErrorHandler>;
}

interface NgxsDevelopmentOptions {
    warnOnUnhandledActions: true | {
        ignore: ActionType[];
    };
}

declare class NgxsDevelopmentModule {
    static forRoot(options: NgxsDevelopmentOptions): ModuleWithProviders<NgxsDevelopmentModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsDevelopmentModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsDevelopmentModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsDevelopmentModule>;
}
declare function withNgxsDevelopmentOptions(options: NgxsDevelopmentOptions): i0.EnvironmentProviders;

declare class NgxsUnhandledActionsLogger {
    /**
     * These actions should be ignored by default; the user can increase this
     * list in the future via the `ignoreActions` method.
     */
    private _ignoredActions;
    constructor();
    /**
     * Adds actions to the internal list of actions that should be ignored.
     */
    ignoreActions(...actions: ActionType[]): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsUnhandledActionsLogger, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsUnhandledActionsLogger>;
}

/**
 * This feature that contributes to app stability, which is required during
 * server-side rendering. With asynchronous actions being dispatched and handled,
 * Angular is unaware of them in zoneless mode and doesn't know whether the app is
 * still unstable. This may prematurely serialize the final HTML that is sent to the client.
 * Including `withNgxsPendingTasks` in your `provideStore` for your SSR
 * app will resolve the above issue.
 */
declare function withNgxsPendingTasks(): i0.EnvironmentProviders;

/**
 * This function provides global store providers and initializes the store.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [provideStore([CountriesState])]
 * });
 * ```
 *
 * The `provideStore` may be optionally called with a config before the list of features:
 *
 * ```ts
 * provideStore([CountriesState], {
 *   developmentMode: !environment.production
 * });
 * ```
 */
declare function provideStore(states?: _StateClass[], ...features: EnvironmentProviders[]): EnvironmentProviders;
declare function provideStore(states?: _StateClass[], options?: NgxsModuleOptions, ...features: EnvironmentProviders[]): EnvironmentProviders;

/**
 * This version serves as a standalone alternative to `NgxsModule.forFeature`.
 * It can be used in a similar manner to register feature states, but at the
 * `Route` providers level:
 *
 * ```ts
 * const routes: Routes = [
 *   {
 *     path: 'products',
 *     loadComponent: async () => {...},
 *     providers: [provideStates([ProductsState])]
 *   }
 * ];
 * ```
 *
 * To lazy-load feature states at the route level,
 * please refer to the `lazyProvider` utility function.
 */
declare function provideStates(states: _StateClass[], ...features: EnvironmentProviders[]): EnvironmentProviders;

/**
 * This function registers a custom global plugin for the state.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPlugin(LogoutPlugin)
 *     )
 *   ]
 * });
 * ```
 */
declare function withNgxsPlugin(plugin: Type<NgxsPlugin> | NgxsPluginFn): EnvironmentProviders;

/**
 * This function registers a preboot function which will be called before the root
 * store initializer is run, but after all of the NGXS features are provided and
 * available for injection. This is useful for registering action stream listeners
 * before any action is dispatched.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPreboot(() => {
 *         const actions$ = inject(Actions);
 *         actions$.subscribe(ctx => console.log(ctx));
 *       })
 *     )
 *   ]
 * });
 * ```
 */
declare function withNgxsPreboot(prebootFn: VoidFunction): i0.EnvironmentProviders;

/**
 * This function serves as a utility and has multiple purposes.
 * Firstly, it allows you to select properties from the state class
 * without having to inject the store class and use `this.store.selectSignal`,
 * resulting in a more concise implementation. Secondly, it can be used with
 * other solutions such as NgRx signal store with its `signalStoreFeature` or
 * `withComputed` functionalities.
 *
 * Please note that it's named `select` instead of `selectSignal` because
 * signals are evolving into first-class primitives in Angular, displacing other
 * primitives such as observables. Observables represent a stream of events,
 * whereas signals represent a single value changing over time.
 */
declare function select<T>(selector: TypedSelector<T>): Signal<T>;

declare function dispatch<TArgs extends any[]>(ActionType: ActionDef<TArgs>): (...args: TArgs) => rxjs.Observable<void>;

type SelectorMap = Record<string, TypedSelector<unknown>>;
declare function createSelectMap<T extends SelectorMap>(selectorMap: T): { readonly [K in keyof T]: Signal<ɵSelectorReturnType<T[K]>>; };

type ActionMap = Record<string, ActionDef<any>>;
declare function createDispatchMap<T extends ActionMap>(actionMap: T): { readonly [K in keyof T]: (...args: ConstructorParameters<T[K]>) => Observable<void>; };

interface DefaultExport<T> {
    default: T;
}
/**
 * This function serves as a utility to lazy-load providers at the injection
 * context level — for example, at the route level. If the feature state needs
 * to be provided in more than one place, it might be indirectly included in
 * the main bundle, which we want to avoid. This function can be used at the
 * guard level to lazy-load the state provider before resolvers run and the
 * component is initialized:
 *
 * ```ts
 * const routes = [
 *   {
 *     path: 'home',
 *     loadComponent: () => import(...),
 *     canActivate: [
 *       lazyProvider(async () => (await import('path-to-state-library')).invoicesStateProvider)
 *     ]
 *   }
 * ];
 * ```
 *
 * Where `invoicesStateProvider` is the following:
 *
 * ```ts
 * // path-to-state-library/index.ts
 *
 * export const invoicesStateProvider = provideStates([InvoicesState]);
 * ```
 */
declare function lazyProvider(factory: () => Promise<EnvironmentProviders | DefaultExport<EnvironmentProviders>>): () => Promise<boolean>;

declare function ɵprovideNgxsInternalStateTokens(): i0.EnvironmentProviders;

export { Action, ActionDirector, ActionStatus, Actions, NgxsConfig, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NgxsUnhandledErrorHandler, Select, Selector, SelectorOptions, State, Store, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, lazyProvider, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPendingTasks, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule, ɵprovideNgxsInternalStateTokens };
export type { ActionCompletion, ActionContext, ActionDef, ActionMap, ActionType, NgxsAfterBootstrap, NgxsDevelopmentOptions, NgxsModuleOptions, NgxsOnChanges, NgxsOnInit, NgxsUnhandledErrorContext, PropertySelectors, SelectorMap, StateContext, TypedSelector, ɵSelectorDef, ɵSelectorFunc, ɵSelectorReturnType, ɵStateSelector };
