import * as i0 from '@angular/core';
import { InjectionToken, Signal } from '@angular/core';
import { Observable, BehaviorSubject, Subject, MonoTypeOperatorFunction } from 'rxjs';

declare class StateToken<T = void> {
    private readonly _name;
    constructor(_name: ɵTokenName<T>);
    getName(): string;
    toString(): string;
}

interface ɵPlainObject {
    [key: string]: any;
}
interface ɵPlainObjectOf<T> {
    [key: string]: T;
}
type ɵStateClass<T = any> = new (...args: any[]) => T;
declare const ɵMETA_KEY = "NGXS_META";
declare const ɵMETA_OPTIONS_KEY = "NGXS_OPTIONS_META";
declare const ɵSELECTOR_META_KEY = "NGXS_SELECTOR_META";
interface ɵStateToken<T, U> {
    new (name: ɵTokenName<T>): U;
    getName(): string;
    toString(): string;
}
type RequireGeneric<T, U> = T extends void ? 'You must provide a type parameter' : U;
type ɵTokenName<T> = string & RequireGeneric<T, string>;
type ɵExtractTokenType<P> = P extends StateToken<infer T> ? T : never;
/**
 * Options that can be provided to the store.
 */
interface ɵStoreOptions<T> {
    /**
     * Name of the state. Required.
     */
    name: string | StateToken<T>;
    /**
     * Default values for the state. If not provided, uses empty object.
     */
    defaults?: T;
    /**
     * Sub states for the given state.
     *
     * @deprecated
     * Read the deprecation notice at this link: https://ngxs.io/deprecations/sub-states-deprecation.
     */
    children?: ɵStateClass[];
}
interface ɵStateClassInternal<T = any, U = any> extends ɵStateClass<T> {
    [ɵMETA_KEY]?: ɵMetaDataModel;
    [ɵMETA_OPTIONS_KEY]?: ɵStoreOptions<U>;
}
interface ɵMetaDataModel {
    name: string | null;
    actions: ɵPlainObjectOf<ɵActionHandlerMetaData[]>;
    defaults: any;
    path: string | null;
    makeRootSelector: ɵSelectorFactory | null;
    /** @deprecated */
    children?: ɵStateClassInternal[];
}
interface ɵSelectorMetaDataModel {
    makeRootSelector: ɵSelectorFactory | null;
    originalFn: Function | null;
    containerClass: any;
    selectorName: string | null;
    getSelectorOptions: () => ɵSharedSelectorOptions;
}
interface ɵSharedSelectorOptions {
    /**
     * @deprecated
     * Read the deprecation notice at this link: https://ngxs.io/deprecations/inject-container-state-deprecation.md.
     */
    injectContainerState?: boolean;
    suppressErrors?: boolean;
}
interface ɵRuntimeSelectorContext {
    getStateGetter(key: any): (state: any) => any;
    getSelectorOptions(localOptions?: ɵSharedSelectorOptions): ɵSharedSelectorOptions;
}
type ɵSelectFromRootState = (rootState: any) => any;
type ɵSelectorFactory = (runtimeContext: ɵRuntimeSelectorContext) => ɵSelectFromRootState;
/**
 * Actions that can be provided in a action decorator.
 */
interface ɵActionOptions {
    /**
     * Cancel the previous uncompleted observable(s).
     */
    cancelUncompleted?: boolean;
}
interface ɵActionHandlerMetaData {
    fn: string | symbol;
    options: ɵActionOptions;
    type: string;
}

/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 */
declare function ɵensureStoreMetadata(target: ɵStateClassInternal): ɵMetaDataModel;
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 */
declare function ɵgetStoreMetadata(target: ɵStateClassInternal): ɵMetaDataModel;
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 */
declare function ɵensureSelectorMetadata(target: Function): ɵSelectorMetaDataModel;
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 */
declare function ɵgetSelectorMetadata(target: any): ɵSelectorMetaDataModel;

/**
 * Memoize a function on its last inputs only.
 * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 */
declare function ɵmemoize<T extends (...args: any[]) => any>(func: T, equalityCheck?: (value1: any, value2: any) => boolean): T;

declare class ɵInitialState {
    private static _value;
    static set(state: ɵPlainObject): void;
    static pop(): ɵPlainObject;
}
declare const ɵINITIAL_STATE_TOKEN: InjectionToken<ɵPlainObject>;

declare class ɵNgxsAppBootstrappedState extends BehaviorSubject<boolean> {
    constructor();
    bootstrap(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ɵNgxsAppBootstrappedState, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ɵNgxsAppBootstrappedState>;
}

declare const ɵNGXS_STATE_FACTORY: InjectionToken<any>;
declare const ɵNGXS_STATE_CONTEXT_FACTORY: InjectionToken<any>;

/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
     subject.subscribe(value => {
       if (value === 'start') subject.next('end');
     });
     subject.subscribe(value => { });
     subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 */
declare class ɵOrderedSubject<T> extends Subject<T> {
    private _orderedNext;
    next(value?: T): void;
}
/**
 * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard BehaviorSubject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new BehaviorSubject<string>();
     subject.subscribe(value => {
       if (value === 'start') subject.next('end');
     });
     subject.subscribe(value => { });
     subject.next('start');
 * ```
 * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.
 */
declare class ɵOrderedBehaviorSubject<T> extends BehaviorSubject<T> {
    private _orderedNext;
    private _currentValue;
    constructor(value: T);
    getValue(): T;
    next(value: T): void;
}

declare function ɵwrapObserverCalls<TValue>(invokeFn: (fn: () => void) => void): MonoTypeOperatorFunction<TValue>;

/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
declare class ɵStateStream extends ɵOrderedBehaviorSubject<ɵPlainObject> {
    readonly state: Signal<ɵPlainObject>;
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<ɵStateStream, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ɵStateStream>;
}

declare const ɵhasOwnProperty: (target: any, key: PropertyKey) => boolean;
declare const ɵdefineProperty: <T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) => T;

type ActionHandlerFn = (action: any) => Observable<unknown>;
declare class ɵNgxsActionRegistry {
    private readonly _actionTypeToHandlersMap;
    constructor();
    get(type: string): Set<ActionHandlerFn> | undefined;
    register(type: string, handler: ActionHandlerFn): () => void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ɵNgxsActionRegistry, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ɵNgxsActionRegistry>;
}

export { StateToken, ɵINITIAL_STATE_TOKEN, ɵInitialState, ɵMETA_KEY, ɵMETA_OPTIONS_KEY, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, ɵNgxsActionRegistry, ɵNgxsAppBootstrappedState, ɵOrderedBehaviorSubject, ɵOrderedSubject, ɵSELECTOR_META_KEY, ɵStateStream, ɵdefineProperty, ɵensureSelectorMetadata, ɵensureStoreMetadata, ɵgetSelectorMetadata, ɵgetStoreMetadata, ɵhasOwnProperty, ɵmemoize, ɵwrapObserverCalls };
export type { ɵActionHandlerMetaData, ɵActionOptions, ɵExtractTokenType, ɵMetaDataModel, ɵPlainObject, ɵPlainObjectOf, ɵRuntimeSelectorContext, ɵSelectFromRootState, ɵSelectorFactory, ɵSelectorMetaDataModel, ɵSharedSelectorOptions, ɵStateClass, ɵStateClassInternal, ɵStateToken, ɵStoreOptions, ɵTokenName };
