{"version":3,"sources":["node_modules/@angular/core/fesm2022/rxjs-interop.mjs","node_modules/@ngxs/store/fesm2022/ngxs-store-internals.mjs","node_modules/@ngxs/store/fesm2022/ngxs-store-plugins.mjs","node_modules/@ngxs/store/fesm2022/ngxs-store-operators.mjs","node_modules/@ngxs/store/fesm2022/ngxs-store.mjs","src/app/current-user/current-user.actions.ts"],"sourcesContent":["/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { assertInInjectionContext, inject, DestroyRef, RuntimeError, Injector, assertNotInReactiveContext, signal, PendingTasks } from './root_effect_scheduler-CWV89N3_.mjs';\nimport { getOutputDestroyRef, effect, untracked, computed, resource, encapsulateResourceError } from './resource-DalzMB4W.mjs';\nimport './primitives/di.mjs';\nimport './signal-nCiHhWf6.mjs';\nimport '@angular/core/primitives/di';\nimport '@angular/core/primitives/signals';\nimport './untracked-DmD_2MlC.mjs';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi 19.0\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable((subscriber) => {\n        if (destroyRef.destroyed) {\n            subscriber.next();\n            return;\n        }\n        const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    source;\n    destroyed = false;\n    destroyRef = inject(DestroyRef);\n    constructor(source) {\n        this.source = source;\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: (value) => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi 19.0\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi 19.0\n */\nfunction outputToObservable(ref) {\n    const destroyRef = getOutputDestroyRef(ref);\n    return new Observable((observer) => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe((v) => observer.next(v));\n        return () => {\n            subscription.unsubscribe();\n            unregisterOnDestroy?.();\n        };\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @publicApi 20.0\n */\nfunction toObservable(source, options) {\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(toObservable);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nfunction toSignal(source, options) {\n    typeof ngDevMode !== 'undefined' &&\n        ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    if (ngDevMode && requiresCleanup && !options?.injector) {\n        assertInInjectionContext(toSignal);\n    }\n    const cleanupRef = requiresCleanup\n        ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n        : null;\n    const equal = makeToSignalEqual(options?.equal);\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });\n    }\n    let destroyUnregisterFn;\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: (error) => {\n            state.set({ kind: 2 /* StateKind.Error */, error });\n            destroyUnregisterFn?.();\n        },\n        complete: () => {\n            destroyUnregisterFn?.();\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    }, { equal: options?.equal });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nfunction pendingUntilEvent(injector) {\n    if (injector === undefined) {\n        ngDevMode && assertInInjectionContext(pendingUntilEvent);\n        injector = inject(Injector);\n    }\n    const taskService = injector.get(PendingTasks);\n    return (sourceObservable) => {\n        return new Observable((originalSubscriber) => {\n            // create a new task on subscription\n            const removeTask = taskService.add();\n            let cleanedUp = false;\n            function cleanupTask() {\n                if (cleanedUp) {\n                    return;\n                }\n                removeTask();\n                cleanedUp = true;\n            }\n            const innerSubscription = sourceObservable.subscribe({\n                next: (v) => {\n                    originalSubscriber.next(v);\n                    cleanupTask();\n                },\n                complete: () => {\n                    originalSubscriber.complete();\n                    cleanupTask();\n                },\n                error: (e) => {\n                    originalSubscriber.error(e);\n                    cleanupTask();\n                },\n            });\n            innerSubscription.add(() => {\n                originalSubscriber.unsubscribe();\n                cleanupTask();\n            });\n            return innerSubscription;\n        });\n    };\n}\n\nfunction rxResource(opts) {\n    if (ngDevMode && !opts?.injector) {\n        assertInInjectionContext(rxResource);\n    }\n    return resource({\n        ...opts,\n        loader: undefined,\n        stream: (params) => {\n            let sub;\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\n            // optimization).\n            const onAbort = () => sub.unsubscribe();\n            params.abortSignal.addEventListener('abort', onAbort);\n            // Start off stream as undefined.\n            const stream = signal({ value: undefined });\n            let resolve;\n            const promise = new Promise((r) => (resolve = r));\n            function send(value) {\n                stream.set(value);\n                resolve?.(stream);\n                resolve = undefined;\n            }\n            // TODO(alxhub): remove after g3 updated to rename loader -> stream\n            const streamFn = opts.stream ?? opts.loader;\n            if (streamFn === undefined) {\n                throw new RuntimeError(990 /* ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION */, ngDevMode && `Must provide \\`stream\\` option.`);\n            }\n            sub = streamFn(params).subscribe({\n                next: (value) => send({ value }),\n                error: (error) => {\n                    send({ error: encapsulateResourceError(error) });\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n                complete: () => {\n                    if (resolve) {\n                        send({\n                            error: new RuntimeError(991 /* ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\n                        });\n                    }\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n            });\n            return promise;\n        },\n    });\n}\n\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal };\n\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, DestroyRef, Injectable, untracked } from '@angular/core';\nimport { BehaviorSubject, Subject, Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n// This key is used to store metadata on state classes,\n// such as actions and other related information.\nconst ɵMETA_KEY = 'NGXS_META';\n// This key is used to store options on state classes\n// provided through the `@State` decorator.\nconst ɵMETA_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n// This key is used to store selector metadata on selector functions,\n// such as decorated with the `@Selector` or provided through the\n// `createSelector` function.\nconst ɵSELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n\n// Property reads are not minified.\n// It's smaller to read it once and use a function.\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nconst ɵhasOwnProperty = (target, key) => _hasOwnProperty.call(target, key);\nconst ɵdefineProperty = Object.defineProperty;\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ɵensureStoreMetadata(target) {\n    if (!ɵhasOwnProperty(target, ɵMETA_KEY)) {\n        const defaultMetadata = {\n            name: null,\n            actions: {},\n            defaults: {},\n            path: null,\n            makeRootSelector(context) {\n                return context.getStateGetter(defaultMetadata.name);\n            },\n            children: []\n        };\n        ɵdefineProperty(target, ɵMETA_KEY, { value: defaultMetadata });\n    }\n    return ɵgetStoreMetadata(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction ɵgetStoreMetadata(target) {\n    return target[ɵMETA_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ɵensureSelectorMetadata(target) {\n    if (!ɵhasOwnProperty(target, ɵSELECTOR_META_KEY)) {\n        const defaultMetadata = {\n            makeRootSelector: null,\n            originalFn: null,\n            containerClass: null,\n            selectorName: null,\n            getSelectorOptions: () => ({})\n        };\n        ɵdefineProperty(target, ɵSELECTOR_META_KEY, { value: defaultMetadata });\n    }\n    return ɵgetSelectorMetadata(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction ɵgetSelectorMetadata(target) {\n    return target[ɵSELECTOR_META_KEY];\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n        return false;\n    }\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can\n    // determine equality as fast as possible.\n    const length = prev.length;\n    for (let i = 0; i < length; i++) {\n        if (!equalityCheck(prev[i], next[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nfunction ɵmemoize(func, equalityCheck = Object.is) {\n    let lastArgs = null;\n    let lastResult = null;\n    // we reference arguments instead of spreading them for performance reasons\n    function memoized() {\n        // eslint-disable-next-line prefer-rest-params\n        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n            // apply arguments instead of spreading for performance.\n            // eslint-disable-next-line prefer-rest-params, prefer-spread\n            lastResult = func.apply(null, arguments);\n        }\n        // eslint-disable-next-line prefer-rest-params\n        lastArgs = arguments;\n        return lastResult;\n    }\n    memoized.reset = function () {\n        // The hidden (for now) ability to reset the memoization\n        lastArgs = null;\n        lastResult = null;\n    };\n    return memoized;\n}\n\nclass StateToken {\n    _name;\n    constructor(_name) {\n        this._name = _name;\n        const selectorMetadata = ɵensureSelectorMetadata(this);\n        selectorMetadata.makeRootSelector = (runtimeContext) => {\n            return runtimeContext.getStateGetter(this._name);\n        };\n    }\n    getName() {\n        return this._name;\n    }\n    toString() {\n        return `StateToken[${this._name}]`;\n    }\n}\n\nclass ɵInitialState {\n    static _value = {};\n    static set(state) {\n        this._value = state;\n    }\n    static pop() {\n        const state = this._value;\n        this._value = {};\n        return state;\n    }\n}\nconst ɵINITIAL_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INITIAL_STATE_TOKEN' : '', {\n    providedIn: 'root',\n    factory: () => ɵInitialState.pop()\n});\n\nclass ɵNgxsAppBootstrappedState extends BehaviorSubject {\n    constructor() {\n        super(false);\n        const destroyRef = inject(DestroyRef);\n        // Complete the subject once the root injector is destroyed to ensure\n        // there are no active subscribers that would receive events or perform\n        // any actions after the application is destroyed.\n        destroyRef.onDestroy(() => this.complete());\n    }\n    bootstrap() {\n        this.next(true);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsAppBootstrappedState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsAppBootstrappedState, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsAppBootstrappedState, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n// These tokens are internal and can change at any point.\nconst ɵNGXS_STATE_FACTORY = /* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ɵNGXS_STATE_FACTORY' : '');\nconst ɵNGXS_STATE_CONTEXT_FACTORY = /* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ɵNGXS_STATE_CONTEXT_FACTORY' : '');\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n    const callsQueue = [];\n    let busyPushingNext = false;\n    return function callOperation(...args) {\n        if (busyPushingNext) {\n            callsQueue.unshift(args);\n            return;\n        }\n        busyPushingNext = true;\n        operation(...args);\n        while (callsQueue.length > 0) {\n            const nextCallArgs = callsQueue.pop();\n            nextCallArgs && operation(...nextCallArgs);\n        }\n        busyPushingNext = false;\n    };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedSubject extends Subject {\n    _orderedNext = orderedQueueOperation((value) => super.next(value));\n    next(value) {\n        this._orderedNext(value);\n    }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedBehaviorSubject extends BehaviorSubject {\n    _orderedNext = orderedQueueOperation((value) => super.next(value));\n    _currentValue;\n    constructor(value) {\n        super(value);\n        this._currentValue = value;\n    }\n    getValue() {\n        return this._currentValue;\n    }\n    next(value) {\n        this._currentValue = value;\n        this._orderedNext(value);\n    }\n}\n\nfunction ɵwrapObserverCalls(invokeFn) {\n    return (source) => {\n        return new Observable(subscriber => {\n            return source.subscribe({\n                next(value) {\n                    invokeFn(() => subscriber.next(value));\n                },\n                error(error) {\n                    invokeFn(() => subscriber.error(error));\n                },\n                complete() {\n                    invokeFn(() => subscriber.complete());\n                }\n            });\n        });\n    };\n}\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass ɵStateStream extends ɵOrderedBehaviorSubject {\n    state = toSignal(this.pipe(ɵwrapObserverCalls(untracked)), {\n        manualCleanup: true,\n        requireSync: true\n    });\n    constructor() {\n        super({});\n        // Complete the subject once the root injector is destroyed to ensure\n        // there are no active subscribers that would receive events or perform\n        // any actions after the application is destroyed.\n        // The `StateStream` should never emit values once the root view is removed,\n        // such as when the `ApplicationRef.destroy()` method is called. This is crucial\n        // for preventing memory leaks in server-side rendered apps, where a new `StateStream`\n        // is created for each HTTP request. If users forget to unsubscribe from `store.select`\n        // or `store.subscribe`, it can result in significant memory leaks in SSR apps.\n        inject(DestroyRef).onDestroy(() => this.complete());\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵStateStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵStateStream, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵStateStream, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass ɵNgxsActionRegistry {\n    // Instead of going over the states list every time an action is dispatched,\n    // we are constructing a map of action types to lists of action metadata.\n    // If the `@@Init` action is handled in two different states, the action\n    // metadata list will contain two objects that have the state `instance` and\n    // method names to be used as action handlers (decorated with `@Action(InitState)`).\n    _actionTypeToHandlersMap = new Map();\n    constructor() {\n        inject(DestroyRef).onDestroy(() => this._actionTypeToHandlersMap.clear());\n    }\n    get(type) {\n        return this._actionTypeToHandlersMap.get(type);\n    }\n    register(type, handler) {\n        const handlers = this._actionTypeToHandlersMap.get(type) ?? new Set();\n        handlers.add(handler);\n        this._actionTypeToHandlersMap.set(type, handlers);\n        return () => {\n            const handlers = this._actionTypeToHandlersMap.get(type);\n            handlers.delete(handler);\n        };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsActionRegistry, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsActionRegistry, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ɵNgxsActionRegistry, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { StateToken, ɵINITIAL_STATE_TOKEN, ɵInitialState, ɵMETA_KEY, ɵMETA_OPTIONS_KEY, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, ɵNgxsActionRegistry, ɵNgxsAppBootstrappedState, ɵOrderedBehaviorSubject, ɵOrderedSubject, ɵSELECTOR_META_KEY, ɵStateStream, ɵdefineProperty, ɵensureSelectorMetadata, ɵensureStoreMetadata, ɵgetSelectorMetadata, ɵgetStoreMetadata, ɵhasOwnProperty, ɵmemoize, ɵwrapObserverCalls };\n\n","import { InjectionToken } from '@angular/core';\n\n/**\n * Init action\n */\nclass InitState {\n    static type = '@@INIT';\n}\n/**\n * Update action\n */\nclass UpdateState {\n    addedStates;\n    static type = '@@UPDATE_STATE';\n    constructor(addedStates) {\n        this.addedStates = addedStates;\n    }\n}\n\n/**\n * A multi-provider token used to resolve to custom NGXS plugins provided\n * at the root and feature levels through the `{provide}` scheme.\n *\n * @deprecated from v18.0.0, use `withNgxsPlugin` instead.\n */\nconst NGXS_PLUGINS = /* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_PLUGINS' : '');\nfunction ɵisPluginClass(plugin) {\n    // Determines whether the provided value is a class rather than a function.\n    // If it’s a class, its handle method should be defined on its prototype,\n    // as plugins can be either classes or functions.\n    return !!plugin.prototype.handle;\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n    return action.constructor?.type || action.type;\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n    const type1 = getActionTypeFromInstance(action1);\n    return function (action2) {\n        return type1 === getActionTypeFromInstance(action2);\n    };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n    obj = { ...obj };\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part] };\n        }\n        return acc?.[part];\n    }, obj);\n    return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc?.[part], obj);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue, ɵisPluginClass };\n\n","const isArray = Array.isArray;\nconst isFunction = (value) => typeof value == 'function';\nconst isStateOperator = isFunction;\nconst isPredicate = isFunction;\nconst isNumber = (value) => typeof value === 'number';\nconst invalidIndex = (index) => Number.isNaN(index) || index === -1;\n\n/**\n * @param items - Specific items to append to the end of an array\n */\nfunction append(items) {\n    return function appendOperator(existing) {\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n        // just return `existing`\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n        if (itemsNotProvidedButExistingIs) {\n            return existing;\n        }\n        if (isArray(existing)) {\n            return existing.concat(items);\n        }\n        // For example if some property is added dynamically\n        // and didn't exist before thus it's not `ArrayLike`\n        return items;\n    };\n}\n\nfunction compose(...operators) {\n    return function composeOperator(existing) {\n        return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n    };\n}\n\nfunction retrieveValue(operatorOrValue, existing) {\n    // If state operator is a function\n    // then call it with an original value\n    if (isStateOperator(operatorOrValue)) {\n        const value = operatorOrValue(existing);\n        return value;\n    }\n    // If operator or value was not provided\n    // e.g. `elseOperatorOrValue` is `undefined`\n    // then we just return an original value\n    if (operatorOrValue === undefined) {\n        return existing;\n    }\n    return operatorOrValue;\n}\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n    return function iifOperator(existing) {\n        // Convert the value to a boolean\n        let result = !!condition;\n        // but if it is a function then run it to get the result\n        if (isPredicate(condition)) {\n            result = condition(existing);\n        }\n        if (result) {\n            return retrieveValue(trueOperatorOrValue, existing);\n        }\n        return retrieveValue(elseOperatorOrValue, existing);\n    };\n}\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nfunction insertItem(value, beforePosition) {\n    return function insertItemOperator(existing) {\n        // Have to check explicitly for `null` and `undefined`\n        // because `value` can be `0`, thus `!value` will return `true`\n        if (value == null && existing) {\n            return existing;\n        }\n        // Property may be dynamic and might not existed before\n        if (!isArray(existing)) {\n            return [value];\n        }\n        const clone = existing.slice();\n        let index = 0;\n        // No need to call `isNumber`\n        // as we are checking `> 0` not `>= 0`\n        // everything except number will return false here\n        if (beforePosition > 0) {\n            index = beforePosition;\n        }\n        clone.splice(index, 0, value);\n        return clone;\n    };\n}\n\nfunction patch(patchObject) {\n    return function patchStateOperator(existing) {\n        let clone = null;\n        for (const k in patchObject) {\n            const newValue = patchObject[k];\n            const existingPropValue = existing?.[k];\n            const newPropValue = isStateOperator(newValue)\n                ? newValue(existingPropValue)\n                : newValue;\n            if (newPropValue !== existingPropValue) {\n                if (!clone) {\n                    clone = { ...existing };\n                }\n                clone[k] = newPropValue;\n            }\n        }\n        return clone || existing;\n    };\n}\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nfunction updateItem(selector, operatorOrValue) {\n    return function updateItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        let value = null;\n        // Need to check if the new item value will change the existing item value\n        // then, only if it will change it then clone the array and set the item\n        const theOperatorOrValue = operatorOrValue;\n        if (isStateOperator(theOperatorOrValue)) {\n            value = theOperatorOrValue(existing[index]);\n        }\n        else {\n            value = theOperatorOrValue;\n        }\n        // If the value hasn't been mutated\n        // then we just return `existing` array\n        if (value === existing[index]) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone[index] = value;\n        return clone;\n    };\n}\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nfunction removeItem(selector) {\n    return function removeItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone.splice(index, 1);\n        return clone;\n    };\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { append, compose, iif, insertItem, isPredicate, isStateOperator, patch, removeItem, updateItem };\n\n","import * as i0 from '@angular/core';\nimport { inject, Injectable, DestroyRef, NgZone, Injector, runInInjectionContext, InjectionToken, ErrorHandler, ɵisPromise as _isPromise, computed, makeEnvironmentProviders, provideEnvironmentInitializer, NgModule, APP_BOOTSTRAP_LISTENER, ApplicationRef, PendingTasks, assertInInjectionContext, EnvironmentInjector, createEnvironmentInjector } from '@angular/core';\nimport { config, Observable, Subject, of, forkJoin, map, shareReplay, filter, take, mergeMap, EMPTY, from, isObservable, defaultIfEmpty, takeUntil, finalize, catchError, distinctUntilChanged, startWith, skip, buffer, debounceTime } from 'rxjs';\nimport { ɵwrapObserverCalls as _wrapObserverCalls, ɵOrderedSubject as _OrderedSubject, ɵStateStream as _StateStream, ɵhasOwnProperty as _hasOwnProperty, ɵmemoize as _memoize, ɵgetStoreMetadata as _getStoreMetadata, ɵgetSelectorMetadata as _getSelectorMetadata, ɵMETA_KEY as _META_KEY, ɵINITIAL_STATE_TOKEN as _INITIAL_STATE_TOKEN, ɵNgxsActionRegistry as _NgxsActionRegistry, ɵNgxsAppBootstrappedState as _NgxsAppBootstrappedState, ɵensureStoreMetadata as _ensureStoreMetadata, ɵMETA_OPTIONS_KEY as _META_OPTIONS_KEY, ɵensureSelectorMetadata as _ensureSelectorMetadata, ɵNGXS_STATE_CONTEXT_FACTORY as _NGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY as _NGXS_STATE_FACTORY } from '@ngxs/store/internals';\nexport { StateToken } from '@ngxs/store/internals';\nimport { NGXS_PLUGINS, getActionTypeFromInstance, InitState, UpdateState, setValue, getValue, ɵisPluginClass as _isPluginClass } from '@ngxs/store/plugins';\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';\nimport { isStateOperator } from '@ngxs/store/operators';\n\nclass PluginManager {\n    plugins = [];\n    _parentManager = inject(PluginManager, {\n        optional: true,\n        skipSelf: true\n    });\n    _pluginHandlers = inject(NGXS_PLUGINS, {\n        optional: true\n    });\n    constructor() {\n        this.registerHandlers();\n    }\n    get _rootPlugins() {\n        return this._parentManager?.plugins || this.plugins;\n    }\n    registerHandlers() {\n        const pluginHandlers = this.getPluginHandlers();\n        this._rootPlugins.push(...pluginHandlers);\n    }\n    getPluginHandlers() {\n        const handlers = this._pluginHandlers || [];\n        return handlers.map((plugin) => (plugin.handle ? plugin.handle.bind(plugin) : plugin));\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: PluginManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: PluginManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: PluginManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n    return _wrapObserverCalls(fn => ngxsExecutionStrategy.leave(fn));\n}\n\nconst ɵɵunhandledRxjsErrorCallbacks = new WeakMap();\nlet installed = false;\nfunction installOnUnhandhedErrorHandler() {\n    if (installed) {\n        return;\n    }\n    const existingHandler = config.onUnhandledError;\n    config.onUnhandledError = function (error) {\n        const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n        if (unhandledErrorCallback) {\n            unhandledErrorCallback();\n        }\n        else if (existingHandler) {\n            existingHandler.call(this, error);\n        }\n        else {\n            throw error;\n        }\n    };\n    installed = true;\n}\nfunction executeUnhandledCallback(error) {\n    const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n    if (unhandledErrorCallback) {\n        unhandledErrorCallback();\n        return true;\n    }\n    return false;\n}\nfunction assignUnhandledCallback(error, callback) {\n    // Since the error can be essentially anything, we must ensure that we only\n    // handle objects, as weak maps do not allow any other key type besides objects.\n    // The error can also be a string if thrown in the following manner: `throwError('My Error')`.\n    if (error && typeof error === 'object') {\n        let hasBeenCalled = false;\n        ɵɵunhandledRxjsErrorCallbacks.set(error, () => {\n            if (!hasBeenCalled) {\n                hasBeenCalled = true;\n                callback();\n            }\n        });\n    }\n    return error;\n}\n\nfunction fallbackSubscriber(ngZone) {\n    return (source) => {\n        let subscription = source.subscribe({\n            error: error => {\n                ngZone.runOutsideAngular(() => {\n                    // This is necessary to schedule a microtask to ensure that synchronous\n                    // errors are not reported before the real subscriber arrives. If an error\n                    // is thrown synchronously in any action, it will be reported to the error\n                    // handler regardless. Since RxJS reports unhandled errors asynchronously,\n                    // implementing a microtask ensures that we are also safe in this scenario.\n                    queueMicrotask(() => {\n                        if (subscription) {\n                            executeUnhandledCallback(error);\n                        }\n                    });\n                });\n            }\n        });\n        return new Observable(subscriber => {\n            // Now that there is a real subscriber, we can unsubscribe our pro-active subscription\n            subscription?.unsubscribe();\n            subscription = null;\n            return source.subscribe(subscriber);\n        });\n    };\n}\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n    constructor() {\n        super();\n        // Complete the subject once the root injector is destroyed to ensure\n        // there are no active subscribers that would receive events or perform\n        // any actions after the application is destroyed.\n        inject(DestroyRef).onDestroy(() => this.complete());\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatchedActionResults, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatchedActionResults, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatchedActionResults, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass InternalNgxsExecutionStrategy {\n    _ngZone = inject(NgZone);\n    enter(func) {\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n            return this._runInsideAngular(func);\n        }\n        return this._runOutsideAngular(func);\n    }\n    leave(func) {\n        return this._runInsideAngular(func);\n    }\n    _runInsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return func();\n        }\n        return this._ngZone.run(func);\n    }\n    _runOutsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return this._ngZone.runOutsideAngular(func);\n        }\n        return func();\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalNgxsExecutionStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalNgxsExecutionStrategy, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Status of a dispatched action\n */\nvar ActionStatus;\n(function (ActionStatus) {\n    ActionStatus[\"Dispatched\"] = \"DISPATCHED\";\n    ActionStatus[\"Successful\"] = \"SUCCESSFUL\";\n    ActionStatus[\"Canceled\"] = \"CANCELED\";\n    ActionStatus[\"Errored\"] = \"ERRORED\";\n})(ActionStatus || (ActionStatus = {}));\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends _OrderedSubject {\n    // This subject will be the first to know about the dispatched action, its purpose is for\n    // any logic that must be executed before action handlers are invoked (i.e., cancelation).\n    dispatched$ = new Subject();\n    constructor() {\n        super();\n        this.subscribe(ctx => {\n            if (ctx.status === ActionStatus.Dispatched) {\n                this.dispatched$.next(ctx);\n            }\n        });\n        const destroyRef = inject(DestroyRef);\n        destroyRef.onDestroy(() => {\n            // Complete the subject once the root injector is destroyed to ensure\n            // there are no active subscribers that would receive events or perform\n            // any actions after the application is destroyed.\n            this.complete();\n            this.dispatched$.complete();\n        });\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActions, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n    constructor() {\n        const internalActions$ = inject(InternalActions);\n        const internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n        // The `InternalActions` subject emits outside of the Angular zone.\n        // We have to re-enter the Angular zone for any incoming consumer.\n        // The shared `Subject` reduces the number of change detections.\n        // This would call leave only once for any stream emission across all active subscribers.\n        const sharedInternalActions$ = new Subject();\n        internalActions$\n            .pipe(leaveNgxs(internalExecutionStrategy))\n            .subscribe(sharedInternalActions$);\n        super(observer => {\n            const childSubscription = sharedInternalActions$.subscribe({\n                next: ctx => observer.next(ctx),\n                error: error => observer.error(error),\n                complete: () => observer.complete()\n            });\n            observer.add(childSubscription);\n        });\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Actions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Actions, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Actions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass InternalDispatcher {\n    _ngZone = inject(NgZone);\n    _actions = inject(InternalActions);\n    _actionResults = inject(InternalDispatchedActionResults);\n    _pluginManager = inject(PluginManager);\n    _stateStream = inject(_StateStream);\n    _ngxsExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n    _injector = inject(Injector);\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n        return result.pipe(fallbackSubscriber(this._ngZone), leaveNgxs(this._ngxsExecutionStrategy));\n    }\n    dispatchByEvents(actionOrActions) {\n        if (Array.isArray(actionOrActions)) {\n            if (actionOrActions.length === 0)\n                return of(undefined);\n            return forkJoin(actionOrActions.map(action => this.dispatchSingle(action))).pipe(map(() => undefined));\n        }\n        else {\n            return this.dispatchSingle(actionOrActions);\n        }\n    }\n    dispatchSingle(action) {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            const type = getActionTypeFromInstance(action);\n            if (!type) {\n                const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n                return new Observable(subscriber => subscriber.error(error));\n            }\n        }\n        const prevState = this._stateStream.getValue();\n        const plugins = this._pluginManager.plugins;\n        return compose(this._injector, [\n            ...plugins,\n            (nextState, nextAction) => {\n                if (nextState !== prevState) {\n                    this._stateStream.next(nextState);\n                }\n                const actionResult$ = this.getActionResultStream(nextAction);\n                actionResult$.subscribe(ctx => this._actions.next(ctx));\n                this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });\n                return this.createDispatchObservable(actionResult$);\n            }\n        ])(prevState, action).pipe(shareReplay());\n    }\n    getActionResultStream(action) {\n        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== ActionStatus.Dispatched), take(1), shareReplay());\n    }\n    createDispatchObservable(actionResult$) {\n        return actionResult$.pipe(mergeMap((ctx) => {\n            switch (ctx.status) {\n                case ActionStatus.Successful:\n                    // The `createDispatchObservable` function should return the\n                    // state, as its result is used by plugins.\n                    return of(this._stateStream.getValue());\n                case ActionStatus.Errored:\n                    throw ctx.error;\n                default:\n                    // Once dispatched or canceled, we complete it immediately because\n                    // `dispatch()` should emit (or error, or complete) as soon as it succeeds or fails.\n                    return EMPTY;\n            }\n        }), shareReplay());\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatcher, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n */\nconst compose = (injector, funcs) => (...args) => {\n    const curr = funcs.shift();\n    return runInInjectionContext(injector, () => curr(...args, (...nextArgs) => compose(injector, funcs)(...nextArgs)));\n};\n\n// The injection token is used to resolve a list of states provided at\n// the root level through either `NgxsModule.forRoot` or `provideStore`.\nconst ROOT_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROOT_STATE_TOKEN' : '');\n// The injection token is used to resolve a list of states provided at\n// the feature level through either `NgxsModule.forFeature` or `provideStates`.\n// The Array<Array> is used to overload the resolved value of the token because\n// it is a multi-provider token.\nconst FEATURE_STATE_TOKEN = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FEATURE_STATE_TOKEN' : '');\n// The injection token is used to resolve to options provided at the root\n// level through either `NgxsModule.forRoot` or `provideStore`.\nconst NGXS_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_OPTIONS' : '');\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n    /**\n     * Run in development mode. This will add additional debugging features:\n     * - Object.freeze on the state and actions to guarantee immutability\n     * (default: false)\n     *\n     * Note: this property will be accounted only in development mode.\n     * It makes sense to use it only during development to ensure there're no state mutations.\n     * When building for production, the `Object.freeze` will be tree-shaken away.\n     */\n    developmentMode;\n    compatibility = {\n        strictContentSecurityPolicy: false\n    };\n    /**\n     * Defining shared selector options\n     */\n    selectorOptions = {\n        injectContainerState: false,\n        suppressErrors: false\n    };\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsConfig, providedIn: 'root', useFactory: () => {\n            const defaultConfig = new NgxsConfig();\n            const config = inject(NGXS_OPTIONS);\n            return {\n                ...defaultConfig,\n                ...config,\n                selectorOptions: {\n                    ...defaultConfig.selectorOptions,\n                    ...config.selectorOptions\n                }\n            };\n        } });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                    useFactory: () => {\n                        const defaultConfig = new NgxsConfig();\n                        const config = inject(NGXS_OPTIONS);\n                        return {\n                            ...defaultConfig,\n                            ...config,\n                            selectorOptions: {\n                                ...defaultConfig.selectorOptions,\n                                ...config.selectorOptions\n                            }\n                        };\n                    }\n                }]\n        }] });\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n    previousValue;\n    currentValue;\n    firstChange;\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n}\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = (o) => {\n    Object.freeze(o);\n    const oIsFunction = typeof o === 'function';\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (_hasOwnProperty(o, prop) &&\n            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n            o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n};\n\n/**\n * @ignore\n */\nclass InternalStateOperations {\n    _stateStream = inject(_StateStream);\n    _dispatcher = inject(InternalDispatcher);\n    _config = inject(NgxsConfig);\n    /**\n     * Returns the root state operators.\n     */\n    getRootStateOperations() {\n        const rootStateOperations = {\n            getState: () => this._stateStream.getValue(),\n            setState: (newState) => this._stateStream.next(newState),\n            dispatch: (actionOrActions) => this._dispatcher.dispatch(actionOrActions)\n        };\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            return this._config.developmentMode\n                ? ensureStateAndActionsAreImmutable(rootStateOperations)\n                : rootStateOperations;\n        }\n        else {\n            return rootStateOperations;\n        }\n    }\n    setStateToTheCurrentWithNew(results) {\n        const stateOperations = this.getRootStateOperations();\n        // Get our current stream\n        const currentState = stateOperations.getState();\n        // Set the state to the current + new\n        stateOperations.setState({ ...currentState, ...results.defaults });\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalStateOperations, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalStateOperations, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalStateOperations, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\nfunction ensureStateAndActionsAreImmutable(root) {\n    return {\n        getState: () => root.getState(),\n        setState: value => {\n            const frozenValue = deepFreeze(value);\n            return root.setState(frozenValue);\n        },\n        dispatch: actions => {\n            return root.dispatch(actions);\n        }\n    };\n}\n\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n    return (context) => {\n        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n        const { suppressErrors } = selectorOptions;\n        return function selectFromRoot(rootState) {\n            // Determine arguments from the app state using the selectors\n            const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n            // If the lambda attempts to access something in the state that doesn't exist,\n            // it will throw a `TypeError`. Since this behavior is common, we simply return\n            // `undefined` in such cases.\n            try {\n                return memoizedSelectorFn(...results);\n            }\n            catch (ex) {\n                if (suppressErrors && ex instanceof TypeError) {\n                    return undefined;\n                }\n                // We're logging an error in this function because it may be used by `select`,\n                // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch\n                // exceptions there to log errors.\n                if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                    const message = 'The selector below has thrown an error upon invocation. ' +\n                        'Please check for any unsafe property access that may result in null ' +\n                        'or undefined values.';\n                    // Avoid concatenating the message with the original function, as this will\n                    // invoke `toString()` on the function. Instead, log it as the second argument.\n                    // This way, developers will be able to navigate to the actual code in the browser.\n                    console.error(message, selectorMetaData.originalFn);\n                }\n                throw ex;\n            }\n        };\n    };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n    const containerClass = creationMetadata?.containerClass;\n    const wrappedFn = function wrappedSelectorFn() {\n        // eslint-disable-next-line prefer-rest-params\n        const returnValue = originalFn.apply(containerClass, arguments);\n        if (typeof returnValue === 'function') {\n            const innerMemoizedFn = _memoize.apply(null, [returnValue]);\n            return innerMemoizedFn;\n        }\n        return returnValue;\n    };\n    const memoizedFn = _memoize(wrappedFn);\n    Object.setPrototypeOf(memoizedFn, originalFn);\n    return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n    const localSelectorOptions = selectorMetaData.getSelectorOptions();\n    const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n    const argumentSelectorFunctions = selectorsToApply.map(selector => {\n        const factory = getRootSelectorFactory(selector);\n        return factory(context);\n    });\n    return {\n        selectorOptions,\n        argumentSelectorFunctions\n    };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n    const selectorsToApply = [];\n    // The container state refers to the state class that includes the\n    // definition of the selector function, for example:\n    // @State()\n    // class AnimalsState {\n    //   @Selector()\n    //   static getAnimals(state: AnimalsStateModel) {}\n    // }\n    // The `AnimalsState` serves as the container state. Additionally, the\n    // selector may reside within a namespace or another class lacking the\n    // `@State` decorator, thus not being treated as the container state.\n    const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;\n    if (containerClass && canInjectContainerState) {\n        // If we are on a state class, add it as the first selector parameter\n        const metadata = _getStoreMetadata(containerClass);\n        if (metadata) {\n            selectorsToApply.push(containerClass);\n        }\n    }\n    selectorsToApply.push(...selectors);\n    return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n    const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n    return metadata?.makeRootSelector || (() => selector);\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n    return obj => {\n        for (let i = 0; i < paths.length; i++) {\n            if (!obj)\n                return undefined;\n            obj = obj[paths[i]];\n        }\n        return obj;\n    };\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n    const segments = paths;\n    let seg = 'store.' + segments[0];\n    let i = 0;\n    const l = segments.length;\n    let expr = seg;\n    while (++i < l) {\n        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n    }\n    const fn = new Function('store', 'return ' + expr + ';');\n    return fn;\n}\nconst ɵPROP_GETTER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PROP_GETTER' : '', {\n    providedIn: 'root',\n    factory: () => inject(NgxsConfig).compatibility?.strictContentSecurityPolicy\n        ? compliantPropGetter\n        : fastPropGetter\n});\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n    // Resolve a state's name from the class reference.\n    const findName = (stateClass) => {\n        const meta = stateClasses.find(s => s === stateClass);\n        if (typeof ngDevMode !== 'undefined' && ngDevMode && !meta) {\n            throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n        }\n        return meta[_META_KEY].name;\n    };\n    // Build the dependency graph.\n    return stateClasses.reduce((graph, stateClass) => {\n        const meta = stateClass[_META_KEY];\n        graph[meta.name] = (meta.children || []).map(findName);\n        return graph;\n    }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n    return states.reduce((result, stateClass) => {\n        const meta = stateClass[_META_KEY];\n        result[meta.name] = stateClass;\n        return result;\n    }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, out = {}) {\n    // Recursively find the full dotted parent path for a given key.\n    const find = (graph, target) => {\n        for (const key in graph) {\n            if (graph[key]?.includes(target)) {\n                const parent = find(graph, key);\n                return parent ? `${parent}.${key}` : key;\n            }\n        }\n        return null;\n    };\n    // Build full path for each key\n    for (const key in obj) {\n        const parent = find(obj, key);\n        out[key] = parent ? `${parent}.${key}` : key;\n    }\n    return out;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n    const sorted = [];\n    const visited = {};\n    // DFS (Depth-First Search) to visit each node and its dependencies.\n    const visit = (name, ancestors = []) => {\n        visited[name] = true;\n        ancestors.push(name);\n        for (const dep of graph[name]) {\n            if (typeof ngDevMode !== 'undefined' && ngDevMode && ancestors.includes(dep)) {\n                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n            }\n            if (!visited[dep])\n                visit(dep, ancestors.slice());\n        }\n        // Add to sorted list if not already included.\n        if (!sorted.includes(name))\n            sorted.push(name);\n    };\n    // Start DFS from each key\n    for (const key in graph)\n        visit(key);\n    return sorted.reverse();\n}\n\nfunction throwStateNameError(name) {\n    throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n    throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n    throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n    throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n    throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n    throw new Error('Selectors only work on methods.');\n}\nfunction getUndecoratedStateWithInjectableWarningMessage(name) {\n    return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction getInvalidInitializationOrderMessage(addedStates) {\n    let message = 'You have an invalid state initialization order. This typically occurs when `NgxsModule.forFeature`\\n' +\n        'or `provideStates` is called before `NgxsModule.forRoot` or `provideStore`.\\n' +\n        'One example is when `NgxsRouterPluginModule.forRoot` is called before `NgxsModule.forRoot`.';\n    if (addedStates) {\n        const stateNames = Object.keys(addedStates).map(stateName => `\"${stateName}\"`);\n        message +=\n            '\\nFeature states added before the store initialization is complete: ' +\n                `${stateNames.join(', ')}.`;\n    }\n    return message;\n}\nfunction throwPatchingArrayError() {\n    throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n    throw new Error('Patching primitives is not supported.');\n}\n\nconst stateNameRegex = /* @__PURE__ */ new RegExp('^[a-zA-Z0-9_]+$');\nfunction ensureStateNameIsValid(name) {\n    if (!name) {\n        throwStateNamePropertyError();\n    }\n    else if (!stateNameRegex.test(name)) {\n        throwStateNameError(name);\n    }\n}\nfunction ensureStateNameIsUnique(stateName, state, statesByName) {\n    const existingState = statesByName[stateName];\n    if (existingState && existingState !== state) {\n        throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n}\nfunction ensureStatesAreDecorated(stateClasses) {\n    stateClasses.forEach((stateClass) => {\n        if (!_getStoreMetadata(stateClass)) {\n            throwStateDecoratorError(stateClass.name);\n        }\n    });\n}\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n    if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n        return;\n    }\n    console.warn(getUndecoratedStateWithInjectableWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n    // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n    // AOT mode because this property is added before runtime. If an application is running in\n    // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n    // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n    return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n    // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n    const annotations = stateClass.__annotations__ || [];\n    return annotations.some((annotation) => annotation?.ngMetadataName === 'Injectable');\n}\n\nconst NGXS_DEVELOPMENT_OPTIONS = \n/* @__PURE__ */ new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_DEVELOPMENT_OPTIONS' : '', {\n    providedIn: 'root',\n    factory: () => ({ warnOnUnhandledActions: true })\n});\n\nclass NgxsUnhandledActionsLogger {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    _ignoredActions = new Set([InitState.type, UpdateState.type]);\n    constructor() {\n        const options = inject(NGXS_DEVELOPMENT_OPTIONS);\n        if (typeof options.warnOnUnhandledActions === 'object') {\n            this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n        }\n    }\n    /**\n     * Adds actions to the internal list of actions that should be ignored.\n     */\n    ignoreActions(...actions) {\n        for (const action of actions) {\n            this._ignoredActions.add(action.type);\n        }\n    }\n    /** @internal */\n    warn(action) {\n        const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n        if (actionShouldBeIgnored) {\n            return;\n        }\n        action =\n            action.constructor && action.constructor.name !== 'Object'\n                ? action.constructor.name\n                : action.type;\n        console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledActionsLogger, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledActionsLogger });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledActionsLogger, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [] });\n\nclass NgxsUnhandledErrorHandler {\n    _ngZone = inject(NgZone);\n    _errorHandler = inject(ErrorHandler);\n    /**\n     * The `_unhandledErrorContext` is left unused internally since we do not\n     * require it for internal operations. However, developers who wish to provide\n     * their own custom error handler may utilize this context information.\n     */\n    handleError(error, _unhandledErrorContext) {\n        // In order to avoid duplicate error handling, it is necessary to leave\n        // the Angular zone to ensure that errors are not caught twice. The `handleError`\n        // method may contain a `throw error` statement, which is used to re-throw the error.\n        // If the error is re-thrown within the Angular zone, it will be caught again by the\n        // Angular zone. By default, `@angular/core` leaves the Angular zone when invoking\n        // `handleError` (see `_callAndReportToErrorHandler`).\n        this._ngZone.runOutsideAngular(() => this._errorHandler.handleError(error));\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledErrorHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledErrorHandler, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsUnhandledErrorHandler, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n    return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [ActionStatus.Dispatched]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [ActionStatus.Successful]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [ActionStatus.Canceled]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n    const allowedStatuses = [\n        ActionStatus.Successful,\n        ActionStatus.Canceled,\n        ActionStatus.Errored\n    ];\n    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [ActionStatus.Errored], mapActionResult);\n}\nfunction ofActionOperator(allowedTypes, statuses, \n// This could have been written as\n// `OperatorFunction<ActionContext, ActionCompletion | any>`, as it maps\n// either to `ctx.action` or to `ActionCompletion`. However,\n// `ActionCompletion | any` defaults to `any`, rendering the union\n// type meaningless.\nmapOperator = mapAction) {\n    const allowedMap = createAllowedActionTypesMap(allowedTypes);\n    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n    return function (o) {\n        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n    };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n    return filter((ctx) => {\n        const actionType = getActionTypeFromInstance(ctx.action);\n        const typeMatch = allowedTypes[actionType];\n        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n        return typeMatch && statusMatch;\n    });\n}\nfunction mapActionResult() {\n    return map(({ action, status, error }) => {\n        return {\n            action,\n            result: {\n                successful: ActionStatus.Successful === status,\n                canceled: ActionStatus.Canceled === status,\n                error\n            }\n        };\n    });\n}\nfunction mapAction() {\n    return map((ctx) => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n    return types.reduce((filterMap, klass) => {\n        filterMap[getActionTypeFromInstance(klass)] = true;\n        return filterMap;\n    }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n    return statuses.reduce((filterMap, status) => {\n        filterMap[status] = true;\n        return filterMap;\n    }, {});\n}\n\nfunction simplePatch(value) {\n    return (existingState) => {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            if (Array.isArray(value)) {\n                throwPatchingArrayError();\n            }\n            else if (typeof value !== 'object') {\n                throwPatchingPrimitiveError();\n            }\n        }\n        const newState = { ...existingState };\n        for (const key in value) {\n            // deep clone for patch compatibility\n            newState[key] = value[key];\n        }\n        return newState;\n    };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n    _internalStateOperations = inject(InternalStateOperations);\n    /**\n     * Create the state context\n     */\n    createStateContext(path) {\n        const root = this._internalStateOperations.getRootStateOperations();\n        return {\n            getState() {\n                const currentAppState = root.getState();\n                return getState(currentAppState, path);\n            },\n            patchState(val) {\n                const currentAppState = root.getState();\n                const patchOperator = simplePatch(val);\n                setStateFromOperator(root, currentAppState, patchOperator, path);\n            },\n            setState(val) {\n                const currentAppState = root.getState();\n                if (isStateOperator(val)) {\n                    setStateFromOperator(root, currentAppState, val, path);\n                }\n                else {\n                    setStateValue(root, currentAppState, val, path);\n                }\n            },\n            dispatch(actions) {\n                return root.dispatch(actions);\n            }\n        };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateContextFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateContextFactory, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateContextFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\nfunction setStateValue(root, currentAppState, newValue, path) {\n    const newAppState = setValue(currentAppState, path, newValue);\n    root.setState(newAppState);\n    return newAppState;\n    // In doing this refactoring I noticed that there is a 'bug' where the\n    // application state is returned instead of this state slice.\n    // This has worked this way since the beginning see:\n    // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n    // This needs to be fixed, but is a 'breaking' change.\n    // I will do this fix in a subsequent PR and we can decide how to handle it.\n}\nfunction setStateFromOperator(root, currentAppState, stateOperator, path) {\n    const local = getState(currentAppState, path);\n    const newValue = stateOperator(local);\n    return setStateValue(root, currentAppState, newValue, path);\n}\nfunction getState(currentAppState, path) {\n    return getValue(currentAppState, path);\n}\n\nclass InternalActionHandlerFactory {\n    _actions = inject(InternalActions);\n    _stateContextFactory = inject(StateContextFactory);\n    createActionHandler(path, handlerFn, options) {\n        const { dispatched$ } = this._actions;\n        return (action) => {\n            const stateContext = this._stateContextFactory.createStateContext(path);\n            let result = handlerFn(stateContext, action);\n            // We need to use `isPromise` instead of checking whether\n            // `result instanceof Promise`. In zone.js patched environments, `global.Promise`\n            // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js\n            // for certain reasons, might not work with `instanceof`. For instance, the dynamic\n            // import returns a native promise (not a `ZoneAwarePromise`), causing this check to\n            // be falsy.\n            if (_isPromise(result)) {\n                result = from(result);\n            }\n            if (isObservable(result)) {\n                result = result.pipe(mergeMap(value => (_isPromise(value) || isObservable(value) ? value : of(value))), \n                // If this observable has completed without emitting any values,\n                // we wouldn't want to complete the entire chain of actions.\n                // If any observable completes, then the action will be canceled.\n                // For instance, if any action handler had a statement like\n                // `handler(ctx) { return EMPTY; }`, then the action would be canceled.\n                // See https://github.com/ngxs/store/issues/1568\n                // Note that we actually don't care about the return type; we only care\n                // about emission, and thus `undefined` is applicable by the framework.\n                defaultIfEmpty(undefined));\n                if (options.cancelUncompleted) {\n                    const canceled = dispatched$.pipe(ofActionDispatched(action));\n                    result = result.pipe(takeUntil(canceled));\n                }\n                result = result.pipe(\n                // Note that we use the `finalize` operator only when the action handler\n                // explicitly returns an observable (or a promise) to wait for. This means\n                // the action handler is written in a \"fire & wait\" style. If the handler’s\n                // result is unsubscribed (either because the observable has completed or\n                // it was unsubscribed by `takeUntil` due to a new action being dispatched),\n                // we prevent writing to the state context.\n                finalize(() => {\n                    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                        function noopAndWarn() {\n                            console.warn(`\"${action}\" attempted to change the state, but the change was ignored because state updates are not allowed after the action handler has completed.`);\n                        }\n                        stateContext.setState = noopAndWarn;\n                        stateContext.patchState = noopAndWarn;\n                    }\n                    else {\n                        stateContext.setState = noop;\n                        stateContext.patchState = noop;\n                    }\n                }));\n            }\n            else {\n                // If the action handler is synchronous and returns nothing (`void`), we\n                // still have to convert the result to a synchronous observable.\n                result = of(undefined);\n            }\n            return result;\n        };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActionHandlerFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActionHandlerFactory, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: InternalActionHandlerFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n// This is used to replace `setState` and `patchState` once the action\n// handler has been unsubscribed or completed, to prevent writing\n// to the state context.\nfunction noop() { }\n\nfunction cloneDefaults(defaults) {\n    let value = defaults === undefined ? {} : defaults;\n    if (defaults) {\n        if (Array.isArray(defaults)) {\n            value = defaults.slice();\n        }\n        else if (typeof defaults === 'object') {\n            value = { ...defaults };\n        }\n    }\n    return value;\n}\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n *\n * Root and feature initializers call `addAndReturnDefaults()` to add those states\n * to the global graph. Since `addAndReturnDefaults` runs within the injection\n * context (which might be the root injector or a feature injector), we can\n * retrieve an instance of the state class using `inject(StateClass)`.\n * @ignore\n */\nclass StateFactory {\n    _injector = inject(Injector);\n    _config = inject(NgxsConfig);\n    _actionHandlerFactory = inject(InternalActionHandlerFactory);\n    _actions = inject(InternalActions);\n    _actionResults = inject(InternalDispatchedActionResults);\n    _initialState = inject(_INITIAL_STATE_TOKEN, { optional: true });\n    _actionRegistry = inject(_NgxsActionRegistry);\n    _propGetter = inject(ɵPROP_GETTER);\n    _actionsSubscription = null;\n    _ngxsUnhandledErrorHandler = null;\n    _states = [];\n    _statesByName = {};\n    _statePaths = {};\n    getRuntimeSelectorContext = _memoize(() => {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const stateFactory = this;\n        const propGetter = stateFactory._propGetter;\n        function resolveGetter(key) {\n            const path = stateFactory._statePaths[key];\n            return path ? propGetter(path.split('.')) : null;\n        }\n        const context = {\n            getStateGetter(key) {\n                // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.\n                // This is a Terser annotation, which will function only in the production mode.\n                let getter = /*@__INLINE__*/ resolveGetter(key);\n                if (getter) {\n                    return getter;\n                }\n                return (...args) => {\n                    // Late loaded getter\n                    if (!getter) {\n                        getter = /*@__INLINE__*/ resolveGetter(key);\n                    }\n                    return getter ? getter(...args) : undefined;\n                };\n            },\n            getSelectorOptions(localOptions) {\n                const globalSelectorOptions = stateFactory._config.selectorOptions;\n                return {\n                    ...globalSelectorOptions,\n                    ...(localOptions || {})\n                };\n            }\n        };\n        return context;\n    });\n    constructor() {\n        inject(DestroyRef).onDestroy(() => this._actionsSubscription?.unsubscribe());\n    }\n    /**\n     * Add a new state to the global defs.\n     */\n    add(stateClasses) {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            ensureStatesAreDecorated(stateClasses);\n        }\n        const { newStates } = this.addToStatesMap(stateClasses);\n        if (!newStates.length)\n            return [];\n        const stateGraph = buildGraph(newStates);\n        const sortedStates = topologicalSort(stateGraph);\n        const paths = findFullParentPath(stateGraph);\n        const nameGraph = nameToState(newStates);\n        const bootstrappedStores = [];\n        for (const name of sortedStates) {\n            const stateClass = nameGraph[name];\n            const path = paths[name];\n            const meta = stateClass[_META_KEY];\n            this.addRuntimeInfoToMeta(meta, path);\n            if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                ensureStateClassIsInjectable(stateClass);\n            }\n            const stateMap = {\n                name,\n                path,\n                isInitialised: false,\n                actions: meta.actions,\n                instance: inject(stateClass),\n                defaults: cloneDefaults(meta.defaults)\n            };\n            // ensure our store hasn't already been added\n            // but don't throw since it could be lazy\n            // loaded from different paths\n            if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n                bootstrappedStores.push(stateMap);\n            }\n            this._states.push(stateMap);\n            this.hydrateActionMetasMap(stateMap);\n        }\n        return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     */\n    addAndReturnDefaults(stateClasses) {\n        const classes = stateClasses || [];\n        const mappedStores = this.add(classes);\n        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n        return { defaults, states: mappedStores };\n    }\n    connectActionHandlers() {\n        this._actionsSubscription = this._actions\n            .pipe(filter((ctx) => ctx.status === ActionStatus.Dispatched), mergeMap(ctx => {\n            const action = ctx.action;\n            return this.invokeActions(action).pipe(map(() => ({ action, status: ActionStatus.Successful })), defaultIfEmpty({ action, status: ActionStatus.Canceled }), catchError(error => {\n                const ngxsUnhandledErrorHandler = (this._ngxsUnhandledErrorHandler ||=\n                    this._injector.get(NgxsUnhandledErrorHandler));\n                const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, { action }));\n                return of({\n                    action,\n                    status: ActionStatus.Errored,\n                    error: handleableError\n                });\n            }));\n        }))\n            .subscribe(ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     */\n    invokeActions(action) {\n        const type = getActionTypeFromInstance(action);\n        const results = [];\n        // Determines whether the dispatched action has been handled, this is assigned\n        // to `true` within the below `for` loop if any `actionMetas` has been found.\n        let actionHasBeenHandled = false;\n        const actionHandlers = this._actionRegistry.get(type);\n        if (actionHandlers) {\n            for (const actionHandler of actionHandlers) {\n                let result;\n                try {\n                    result = actionHandler(action);\n                }\n                catch (e) {\n                    result = new Observable(subscriber => subscriber.error(e));\n                }\n                results.push(result);\n                actionHasBeenHandled = true;\n            }\n        }\n        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n        // only during development.\n        if (typeof ngDevMode !== 'undefined' && ngDevMode && !actionHasBeenHandled) {\n            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n            // didn't return `null` so we may ensure the module has been imported.\n            unhandledActionsLogger?.warn(action);\n        }\n        if (!results.length) {\n            results.push(of(undefined));\n        }\n        return forkJoin(results);\n    }\n    addToStatesMap(stateClasses) {\n        const newStates = [];\n        const statesMap = this._statesByName;\n        for (const stateClass of stateClasses) {\n            const stateName = _getStoreMetadata(stateClass).name;\n            if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                ensureStateNameIsUnique(stateName, stateClass, statesMap);\n            }\n            const unmountedState = !statesMap[stateName];\n            if (unmountedState) {\n                newStates.push(stateClass);\n                statesMap[stateName] = stateClass;\n            }\n        }\n        return { newStates };\n    }\n    addRuntimeInfoToMeta(meta, path) {\n        this._statePaths[meta.name] = path;\n        // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic\n        // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n        // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins\n        meta.path = path;\n    }\n    hasBeenMountedAndBootstrapped(name, path) {\n        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n        // This checks whether a state has been already added to the global graph and\n        // its lifecycle is in 'bootstrapped' state.\n        return this._statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n    hydrateActionMetasMap({ path, actions, instance }) {\n        for (const actionType of Object.keys(actions)) {\n            const actionHandlers = actions[actionType].map(actionMeta => {\n                const handlerFn = (ctx, action) => instance[actionMeta.fn](ctx, action);\n                return this._actionHandlerFactory.createActionHandler(path, handlerFn, actionMeta.options);\n            });\n            for (const actionHandler of actionHandlers) {\n                this._actionRegistry.register(actionType, actionHandler);\n            }\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateFactory, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: StateFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass Store {\n    _stateStream = inject(_StateStream);\n    _internalStateOperations = inject(InternalStateOperations);\n    _config = inject(NgxsConfig);\n    _internalExecutionStrategy = inject(InternalNgxsExecutionStrategy);\n    _stateFactory = inject(StateFactory);\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    _selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));\n    constructor() {\n        this.initStateStream();\n    }\n    /**\n     * Dispatches action(s).\n     */\n    dispatch(actionOrActions) {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            if (\n            // If a single action is dispatched and it's nullable.\n            actionOrActions == null ||\n                // If a list of actions is dispatched and any of the actions are nullable.\n                (Array.isArray(actionOrActions) && actionOrActions.some(action => action == null))) {\n                const error = new Error('`dispatch()` was called without providing an action.');\n                return new Observable(subscriber => subscriber.error(error));\n            }\n        }\n        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    /**\n     * Selects a slice of data from the store.\n     */\n    select(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return this._selectableStateStream.pipe(map(selectorFn), catchError((error) => {\n            // if error is TypeError we swallow it to prevent usual errors with property access\n            if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {\n                return of(undefined);\n            }\n            // rethrow other errors\n            throw error;\n        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    /**\n     * Select one slice of data from the store.\n     */\n    selectOnce(selector) {\n        return this.select(selector).pipe(take(1));\n    }\n    /**\n     * Select a snapshot from the state.\n     */\n    selectSnapshot(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Select a signal from the state.\n     */\n    selectSignal(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return computed(() => selectorFn(this._stateStream.state()));\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn) {\n        return this._selectableStateStream\n            .pipe(leaveNgxs(this._internalExecutionStrategy))\n            .subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot() {\n        return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state) {\n        this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    getStoreBoundSelectorFn(selector) {\n        const makeSelectorFn = getRootSelectorFactory(selector);\n        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n        return makeSelectorFn(runtimeContext);\n    }\n    initStateStream() {\n        const initialStateValue = inject(_INITIAL_STATE_TOKEN);\n        const value = this._stateStream.value;\n        const storeIsEmpty = !value || Object.keys(value).length === 0;\n        if (storeIsEmpty) {\n            this._stateStream.next(initialStateValue);\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Store, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Store, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: Store, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/**\n * InjectionToken that registers preboot functions (called before the root initializer).\n */\nconst NGXS_PREBOOT_FNS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_PREBOOT_FNS' : '');\n/**\n * This function registers a preboot function which will be called before the root\n * store initializer is run, but after all of the NGXS features are provided and\n * available for injection. This is useful for registering action stream listeners\n * before any action is dispatched.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPreboot(() => {\n *         const actions$ = inject(Actions);\n *         actions$.subscribe(ctx => console.log(ctx));\n *       })\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPreboot(prebootFn) {\n    return makeEnvironmentProviders([\n        { provide: NGXS_PREBOOT_FNS, multi: true, useValue: prebootFn }\n    ]);\n}\n\nconst ROOT_STORE_GUARD = /* @__PURE__ */ new InjectionToken('ROOT_STORE_GUARD', {\n    providedIn: 'root',\n    factory: () => ({ initialized: false })\n});\nfunction assertRootStoreNotInitialized() {\n    const rootStoreGuard = inject(ROOT_STORE_GUARD);\n    if (rootStoreGuard.initialized) {\n        throw new Error('provideStore() should only be called once.');\n    }\n    rootStoreGuard.initialized = true;\n}\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n    static store = null;\n    static config = null;\n    constructor(store, config) {\n        SelectFactory.store = store;\n        SelectFactory.config = config;\n        inject(DestroyRef).onDestroy(() => {\n            SelectFactory.store = null;\n            SelectFactory.config = null;\n        });\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: SelectFactory, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: SelectFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: Store }, { type: NgxsConfig }] });\n\nclass LifecycleStateManager {\n    _store = inject(Store);\n    _internalStateOperations = inject(InternalStateOperations);\n    _stateContextFactory = inject(StateContextFactory);\n    _appBootstrappedState = inject(_NgxsAppBootstrappedState);\n    _initStateHasBeenDispatched;\n    ngxsBootstrap(action, results) {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            if (action instanceof InitState) {\n                this._initStateHasBeenDispatched = true;\n            }\n            else if (\n            // This is a dev mode-only check that ensures the correct order of\n            // state initialization. The `NgxsModule.forRoot` or `provideStore` should\n            // always come first, followed by `forFeature` and `provideStates`. If the\n            // `UpdateState` is dispatched before the `InitState` is dispatched, it indicates\n            // that modules or providers are in an invalid order.\n            action instanceof UpdateState &&\n                !this._initStateHasBeenDispatched) {\n                console.error(getInvalidInitializationOrderMessage(action.addedStates));\n            }\n        }\n        // It does not need to unsubscribe because it is completed when the\n        // root injector is destroyed.\n        this._internalStateOperations\n            .getRootStateOperations()\n            .dispatch(action)\n            .pipe(mergeMap(() => {\n            // If no states are provided, we safely complete the stream\n            // and do not proceed further.\n            if (!results) {\n                return EMPTY;\n            }\n            this._invokeInitOnStates(results.states);\n            return this._appBootstrappedState;\n        }))\n            .subscribe(appBootstrapped => {\n            if (appBootstrapped) {\n                this._invokeBootstrapOnStates(results.states);\n            }\n        });\n    }\n    _invokeInitOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsOnChanges) {\n                // We are manually keeping track of the previous value\n                // within the subscribe block in order to drop the `pairwise()` operator.\n                let previousValue;\n                // It does not need to unsubscribe because it is completed when the\n                // root injector is destroyed.\n                this._store\n                    .select(state => getValue(state, mappedStore.path))\n                    .pipe(\n                // Ensure initial state is captured\n                startWith(undefined), \n                // `skip` is using `filter` internally.\n                skip(1))\n                    .subscribe(currentValue => {\n                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n                    previousValue = currentValue;\n                    instance.ngxsOnChanges(change);\n                });\n            }\n            if (instance.ngxsOnInit) {\n                instance.ngxsOnInit(this._getStateContext(mappedStore));\n            }\n            mappedStore.isInitialised = true;\n        }\n    }\n    _invokeBootstrapOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsAfterBootstrap) {\n                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n            }\n        }\n    }\n    _getStateContext(mappedStore) {\n        return this._stateContextFactory.createStateContext(mappedStore.path);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: LifecycleStateManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: LifecycleStateManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: LifecycleStateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * This function is shared by both NgModule and standalone features.\n * When using `NgxsModule.forRoot` and `provideStore`, we can depend on the\n * same initialization functionality.\n */\nfunction rootStoreInitializer() {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        assertRootStoreNotInitialized();\n    }\n    // Override the RxJS `config.onUnhandledError` within the root store initializer,\n    // but only after other code has already executed.\n    // If users have a custom `config.onUnhandledError`, we might overwrite it too\n    // early and capture the original `config.onUnhandledError` before it is properly set.\n    installOnUnhandhedErrorHandler();\n    const prebootFns = inject(NGXS_PREBOOT_FNS, { optional: true }) || [];\n    prebootFns.forEach(prebootFn => prebootFn());\n    const factory = inject(StateFactory);\n    const internalStateOperations = inject(InternalStateOperations);\n    inject(Store);\n    inject(SelectFactory);\n    const states = inject(ROOT_STATE_TOKEN, { optional: true }) || [];\n    const lifecycleStateManager = inject(LifecycleStateManager);\n    // Add stores to the state graph and return their defaults.\n    const results = factory.addAndReturnDefaults(states);\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Connect our actions stream.\n    factory.connectActionHandlers();\n    // Dispatch the init action and invoke init and bootstrap functions after.\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n}\n/**\n * This function is utilized by both NgModule and standalone features.\n * When using `NgxsModule.forFeature` and `provideStates`, we can depend on\n * the same initialization functionality.\n */\nfunction featureStatesInitializer() {\n    inject(Store);\n    const internalStateOperations = inject(InternalStateOperations);\n    const factory = inject(StateFactory);\n    const states = inject(FEATURE_STATE_TOKEN, { optional: true }) || [];\n    const lifecycleStateManager = inject(LifecycleStateManager);\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]].\n    const flattenedStates = states.reduce((total, values) => total.concat(values), []);\n    // add stores to the state graph and return their defaults.\n    const results = factory.addAndReturnDefaults(flattenedStates);\n    if (results.states.length) {\n        internalStateOperations.setStateToTheCurrentWithNew(results);\n        // Dispatch the update action and invoke init and bootstrap functions after.\n        lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n}\n/**\n * InjectionToken that registers the global Store.\n */\nconst NGXS_ROOT_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_ROOT_STORE_INITIALIZER' : '');\n/**\n * InjectionToken that registers feature states.\n */\nconst NGXS_FEATURE_STORE_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NGXS_FEATURE_STORE_INITIALIZER' : '');\nconst NGXS_ROOT_ENVIRONMENT_INITIALIZER = [\n    { provide: NGXS_ROOT_STORE_INITIALIZER, useFactory: rootStoreInitializer },\n    provideEnvironmentInitializer(() => inject(NGXS_ROOT_STORE_INITIALIZER))\n];\n/**\n * The `NGXS_FEATURE_ENVIRONMENT_INITIALIZER` functions as an environment initializer\n * at the `Route` level. Angular Router creates an environment route injector for each\n * matched route where navigation occurs. The injector is created once, ensuring that\n * the feature states initialization only happens once as well.\n */\nconst NGXS_FEATURE_ENVIRONMENT_INITIALIZER = [\n    { provide: NGXS_FEATURE_STORE_INITIALIZER, useFactory: featureStatesInitializer },\n    provideEnvironmentInitializer(() => inject(NGXS_FEATURE_STORE_INITIALIZER))\n];\n\n/**\n * @ignore\n */\nclass NgxsRootModule {\n    constructor() {\n        rootStoreInitializer();\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsRootModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsRootModule });\n    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsRootModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsRootModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: () => [] });\n\n/**\n * @ignore\n */\nclass NgxsFeatureModule {\n    constructor() {\n        featureStatesInitializer();\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsFeatureModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsFeatureModule });\n    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsFeatureModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsFeatureModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: () => [] });\n\n/**\n * This function provides the required providers when invoking `NgxsModule.forRoot`\n * or `provideStore`. It is shared between the NgModule and standalone APIs.\n */\nfunction getRootProviders(states, options) {\n    return [\n        ...states,\n        {\n            provide: ROOT_STATE_TOKEN,\n            useValue: states\n        },\n        {\n            provide: APP_BOOTSTRAP_LISTENER,\n            useFactory: () => {\n                const appBootstrappedState = inject(_NgxsAppBootstrappedState);\n                return () => appBootstrappedState.bootstrap();\n            },\n            multi: true\n        },\n        {\n            provide: NGXS_OPTIONS,\n            useValue: options\n        }\n    ];\n}\n\n/**\n * This function provides the required providers when calling `NgxsModule.forFeature`\n * or `provideStates`. It is shared between the NgModule and standalone APIs.\n */\nfunction getFeatureProviders(states) {\n    return [\n        PluginManager,\n        ...states,\n        {\n            provide: FEATURE_STATE_TOKEN,\n            multi: true,\n            useValue: states\n        }\n    ];\n}\n\nclass NgxsModule {\n    static forRoot(states = [], options = {}) {\n        return {\n            ngModule: NgxsRootModule,\n            providers: getRootProviders(states, options)\n        };\n    }\n    static forFeature(states = []) {\n        return {\n            ngModule: NgxsFeatureModule,\n            providers: getFeatureProviders(states)\n        };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsModule });\n    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * Decorates a method with action information.\n */\nfunction Action(actions, options) {\n    return (target, name, \n    // This parameter ensures that the decorated method has a call signature that could be passed an instance of the given action(s).\n    _descriptor) => {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            const isStaticMethod = _hasOwnProperty(target, 'prototype');\n            if (isStaticMethod) {\n                throwActionDecoratorError();\n            }\n        }\n        const meta = _ensureStoreMetadata(target.constructor);\n        const actionArray = Array.isArray(actions) ? actions : [actions];\n        for (const action of actionArray) {\n            const type = action.type;\n            if (!meta.actions[type]) {\n                meta.actions[type] = [];\n            }\n            meta.actions[type].push({\n                fn: name,\n                options: options || {},\n                type\n            });\n        }\n    };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n    return (target) => {\n        const stateClass = target;\n        const inherited = Object.getPrototypeOf(stateClass);\n        const meta = _ensureStoreMetadata(stateClass);\n        const mergedOptions = { ...(inherited[_META_OPTIONS_KEY] || {}), ...options };\n        // Apply merged options to metadata.\n        mutateMetaData(meta, inherited, mergedOptions);\n        stateClass[_META_OPTIONS_KEY] = mergedOptions;\n    };\n}\n// Updates metadata using inherited and current options\nfunction mutateMetaData(meta, inherited, options) {\n    const { name, defaults, children } = options;\n    const stateName = typeof name === 'string' ? name : name?.getName?.() || null;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureStateNameIsValid(stateName);\n    }\n    if (_hasOwnProperty(inherited, _META_KEY)) {\n        const inheritedMeta = inherited[_META_KEY] || {};\n        meta.actions = { ...meta.actions, ...inheritedMeta.actions };\n    }\n    meta.name = stateName;\n    meta.defaults = defaults;\n    meta.children = children;\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n *\n * Marked for removal. It's only used within `createSelectorFn`.\n */\nfunction propGetter(paths, config) {\n    if (config?.compatibility?.strictContentSecurityPolicy) {\n        return compliantPropGetter(paths);\n    }\n    else {\n        return fastPropGetter(paths);\n    }\n}\nfunction throwSelectFactoryNotConnectedError() {\n    throw new Error('You have forgotten to import the NGXS module!');\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n    if (!SelectFactory.store) {\n        throwSelectFactoryNotConnectedError();\n    }\n    return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n    rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n    if (typeof rawSelector === 'string') {\n        const propsArray = paths.length\n            ? [rawSelector, ...paths]\n            : rawSelector.split('.');\n        return propGetter(propsArray, SelectFactory.config);\n    }\n    return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n    const lastCharIndex = name.length - 1;\n    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n *\n * @deprecated\n * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.\n */\nfunction Select(rawSelector, ...paths) {\n    return function (target, key) {\n        const name = key.toString();\n        const selectorId = `__${name}__selector`;\n        const selector = createSelectorFn(name, rawSelector, paths);\n        Object.defineProperties(target, {\n            [selectorId]: {\n                writable: true,\n                enumerable: false,\n                configurable: true\n            },\n            [name]: {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n                }\n            }\n        });\n    };\n}\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n    getOptions: (target) => {\n        return target?.[SELECTOR_OPTIONS_META_KEY] || {};\n    },\n    defineOptions: (target, options) => {\n        if (!target)\n            return;\n        target[SELECTOR_OPTIONS_META_KEY] = options;\n    }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n    const selectorMetaData = _ensureSelectorMetadata(originalFn);\n    selectorMetaData.originalFn = originalFn;\n    let getExplicitSelectorOptions = () => ({});\n    if (creationMetadata) {\n        selectorMetaData.containerClass = creationMetadata.containerClass;\n        selectorMetaData.selectorName = creationMetadata.selectorName || null;\n        getExplicitSelectorOptions =\n            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n    }\n    const selectorMetaDataClone = { ...selectorMetaData };\n    selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n    return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n    return {\n        ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}),\n        ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}),\n        ...(selectorMetaData.getSelectorOptions() || {}),\n        ...explicitOptions\n    };\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n    return (function decorate(target, methodName, descriptor) {\n        if (methodName) {\n            descriptor ||= Object.getOwnPropertyDescriptor(target, methodName);\n            // Method Decorator\n            const originalFn = descriptor.value || descriptor.originalFn;\n            if (originalFn) {\n                selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n            }\n        }\n        else {\n            // Class Decorator\n            selectorOptionsMetaAccessor.defineOptions(target, options);\n        }\n    });\n}\n\nfunction createSelector(selectors, projector, creationMetadata) {\n    const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n    const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n    selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n    return memoizedFn;\n}\n\nfunction Selector(selectors) {\n    return (target, key, descriptor) => {\n        descriptor ||= Object.getOwnPropertyDescriptor(target, key);\n        const originalFn = descriptor?.value;\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            if (typeof originalFn !== 'function') {\n                throwSelectorDecoratorError();\n            }\n        }\n        const memoizedFn = createSelector(selectors, originalFn, {\n            containerClass: target,\n            selectorName: key.toString(),\n            getSelectorOptions() {\n                return {};\n            }\n        });\n        const newDescriptor = {\n            configurable: true,\n            get() {\n                return memoizedFn;\n            },\n            originalFn\n        };\n        return newDescriptor;\n    };\n}\n\nclass ActionDirector {\n    _registry = inject(_NgxsActionRegistry);\n    _actionHandlerFactory = inject(InternalActionHandlerFactory);\n    attachAction(stateToken, Action, handlerFn, options = {}) {\n        const actionHandler = this._actionHandlerFactory.createActionHandler(stateToken.getName(), handlerFn, options);\n        const detach = this._registry.register(Action.type, actionHandler);\n        return { detach };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ActionDirector, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ActionDirector, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: ActionDirector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nclass NgxsDevelopmentModule {\n    static forRoot(options) {\n        return {\n            ngModule: NgxsDevelopmentModule,\n            providers: [\n                NgxsUnhandledActionsLogger,\n                { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }\n            ]\n        };\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsDevelopmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsDevelopmentModule });\n    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsDevelopmentModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.3\", ngImport: i0, type: NgxsDevelopmentModule, decorators: [{\n            type: NgModule\n        }] });\nfunction withNgxsDevelopmentOptions(options) {\n    return makeEnvironmentProviders([\n        NgxsUnhandledActionsLogger,\n        { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }\n    ]);\n}\n\nfunction getMissingMetaDataError(selector, context = {}) {\n    const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n    if (!metadata) {\n        return new Error(`${context.prefix}The value provided as the ${context.noun} is not a valid selector.`);\n    }\n    return null;\n}\nfunction ensureValidSelector(selector, context = {}) {\n    const noun = context.noun || 'selector';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    ensureValueProvided(selector, { noun, prefix: context.prefix });\n    const error = getMissingMetaDataError(selector, { noun, prefix });\n    if (error) {\n        // If we have used this utility within a state class, we may be\n        //  before the @State or @Selector decorators have been applied.\n        //  wait until the next microtask to verify.\n        // Theoretically this situation is only encountered when the javascript\n        //  files are being loaded and we are outside the angular zone.\n        if (!NgZone.isInAngularZone()) {\n            Promise.resolve().then(() => {\n                const errorAgain = getMissingMetaDataError(selector, { noun, prefix });\n                if (errorAgain) {\n                    // Throw the originally captured error so that the stack trace shows the\n                    // original utility call site.\n                    console.error(error);\n                }\n            });\n        }\n        else {\n            throw error;\n        }\n    }\n}\nfunction ensureValueProvided(value, context = {}) {\n    const noun = context.noun || 'value';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    if (!value) {\n        throw new Error(`${prefix}A ${noun} must be provided.`);\n    }\n}\n\nfunction createModelSelector(selectorMap) {\n    const selectorKeys = Object.keys(selectorMap);\n    const selectors = Object.values(selectorMap);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureValidSelectorMap({\n            prefix: '[createModelSelector]',\n            selectorMap,\n            selectorKeys,\n            selectors\n        });\n    }\n    return createSelector(selectors, (...args) => {\n        return selectorKeys.reduce((obj, key, index) => {\n            obj[key] = args[index];\n            return obj;\n        }, {});\n    });\n}\nfunction ensureValidSelectorMap({ prefix, selectorMap, selectorKeys, selectors }) {\n    ensureValueProvided(selectorMap, { prefix, noun: 'selector map' });\n    ensureValueProvided(typeof selectorMap === 'object', { prefix, noun: 'valid selector map' });\n    ensureValueProvided(selectorKeys.length, { prefix, noun: 'non-empty selector map' });\n    selectors.forEach((selector, index) => ensureValidSelector(selector, {\n        prefix,\n        noun: `selector for the '${selectorKeys[index]}' property`\n    }));\n}\n\nfunction createPickSelector(selector, keys) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureValidSelector(selector, { prefix: '[createPickSelector]' });\n    }\n    const validKeys = keys.filter(Boolean);\n    const selectors = validKeys.map(key => createSelector([selector], (s) => s[key]));\n    return createSelector([...selectors], (...props) => {\n        return validKeys.reduce((acc, key, index) => {\n            acc[key] = props[index];\n            return acc;\n        }, {});\n    });\n}\n\nfunction createPropertySelectors(parentSelector) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        ensureValidSelector(parentSelector, {\n            prefix: '[createPropertySelectors]',\n            noun: 'parent selector'\n        });\n    }\n    const cache = {};\n    return new Proxy({}, {\n        get(_target, prop) {\n            const selector = cache[prop] ||\n                createSelector([parentSelector], (s) => s?.[prop]);\n            cache[prop] = selector;\n            return selector;\n        }\n    });\n}\n\n/**\n * This feature that contributes to app stability, which is required during\n * server-side rendering. With asynchronous actions being dispatched and handled,\n * Angular is unaware of them in zoneless mode and doesn't know whether the app is\n * still unstable. This may prematurely serialize the final HTML that is sent to the client.\n * Including `withNgxsPendingTasks` in your `provideStore` for your SSR\n * app will resolve the above issue.\n */\nfunction withNgxsPendingTasks() {\n    return withNgxsPreboot(() => {\n        const actions$ = inject(Actions);\n        const appRef = inject(ApplicationRef);\n        const pendingTasks = inject(PendingTasks);\n        // Removing a pending task via the public API forces a scheduled tick, ensuring that\n        // stability is async and delayed until there was at least an opportunity to run\n        // app synchronization.\n        // Adding a new task every time an action is dispatched drastically increases the\n        // number of change detection cycles because removing a task schedules a new change\n        // detection cycle.\n        // If 10 actions are dispatched with synchronous action handlers, this would trigger\n        // 10 change detection cycles in a row, potentially leading to an\n        // `INFINITE_CHANGE_DETECTION` error.\n        let removeTask = null;\n        const executedActions = new Set();\n        // If the app is forcely destroyed before all actions are completed,\n        // we clean up the set of actions being executed to prevent memory leaks\n        // and remove the pending task to stabilize the app.\n        appRef.onDestroy(() => executedActions.clear());\n        let isStable = false;\n        appRef.whenStable().then(() => {\n            isStable = true;\n        });\n        const subscription = actions$\n            .pipe(filter(context => {\n            if (context.status === ActionStatus.Dispatched) {\n                executedActions.add(context.action);\n                removeTask ||= pendingTasks.add();\n                return false;\n            }\n            else {\n                return true;\n            }\n        }), \n        // Every time an action is completed, we debounce the stream to ensure only one\n        // task is removed, even if multiple synchronous actions are completed in a row.\n        // We use `buffer` to collect action contexts because, if we only use\n        // `debounceTime(0)`, we may lose action contexts that are never removed from the set.\n        buffer(actions$.pipe(debounceTime(0))))\n            .subscribe(contexts => {\n            for (const context of contexts) {\n                if (!executedActions.has(context.action)) {\n                    continue;\n                }\n                executedActions.delete(context.action);\n                // Mark app as stable once all of the debounced actions have completed.\n                if (executedActions.size === 0) {\n                    removeTask?.();\n                    removeTask = null;\n                    if (isStable) {\n                        // Stop contributing to stability once the application has become stable,\n                        // which may happen on the server before the platform is destroyed or in\n                        // the browser once hydration is complete.\n                        subscription.unsubscribe();\n                    }\n                }\n            }\n        });\n    });\n}\n\nfunction provideStore(states = [], ...optionsAndFeatures) {\n    const features = [];\n    // Options are empty by default (see `forRoot`).\n    let options = {};\n    if (optionsAndFeatures.length > 0) {\n        if (isEnvironmentProvider(optionsAndFeatures[0])) {\n            features.push(...optionsAndFeatures);\n        }\n        else {\n            options = optionsAndFeatures[0];\n            features.push(...optionsAndFeatures.slice(1));\n        }\n    }\n    return makeEnvironmentProviders([\n        ...getRootProviders(states, options),\n        NGXS_ROOT_ENVIRONMENT_INITIALIZER,\n        features\n    ]);\n}\nfunction isEnvironmentProvider(target) {\n    return !!target.ɵproviders;\n}\n\n/**\n * This version serves as a standalone alternative to `NgxsModule.forFeature`.\n * It can be used in a similar manner to register feature states, but at the\n * `Route` providers level:\n *\n * ```ts\n * const routes: Routes = [\n *   {\n *     path: 'products',\n *     loadComponent: async () => {...},\n *     providers: [provideStates([ProductsState])]\n *   }\n * ];\n * ```\n *\n * To lazy-load feature states at the route level,\n * please refer to the `lazyProvider` utility function.\n */\nfunction provideStates(states, ...features) {\n    return makeEnvironmentProviders([\n        ...getFeatureProviders(states),\n        features,\n        NGXS_FEATURE_ENVIRONMENT_INITIALIZER\n    ]);\n}\n\n/**\n * This function registers a custom global plugin for the state.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPlugin(LogoutPlugin)\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPlugin(plugin) {\n    return makeEnvironmentProviders([\n        _isPluginClass(plugin)\n            ? { provide: NGXS_PLUGINS, useClass: plugin, multi: true }\n            : { provide: NGXS_PLUGINS, useValue: plugin, multi: true },\n        // We should inject the `PluginManager` to retrieve `NGXS_PLUGINS` and\n        // register those plugins. The plugin can be added from inside the child\n        // route, so the plugin manager should be re-injected.\n        provideEnvironmentInitializer(() => inject(PluginManager))\n    ]);\n}\n\n/**\n * This function serves as a utility and has multiple purposes.\n * Firstly, it allows you to select properties from the state class\n * without having to inject the store class and use `this.store.selectSignal`,\n * resulting in a more concise implementation. Secondly, it can be used with\n * other solutions such as NgRx signal store with its `signalStoreFeature` or\n * `withComputed` functionalities.\n *\n * Please note that it's named `select` instead of `selectSignal` because\n * signals are evolving into first-class primitives in Angular, displacing other\n * primitives such as observables. Observables represent a stream of events,\n * whereas signals represent a single value changing over time.\n */\nfunction select(selector) {\n    return inject(Store).selectSignal(selector);\n}\n\nfunction dispatch(ActionType) {\n    const store = inject(Store);\n    return (...args) => store.dispatch(new ActionType(...args));\n}\n\nfunction createSelectMap(selectorMap) {\n    const store = inject(Store);\n    return Object.entries(selectorMap).reduce((accumulator, [key, selector]) => {\n        accumulator[key] = store.selectSignal(selector);\n        return accumulator;\n    }, {});\n}\n\nfunction createDispatchMap(actionMap) {\n    return Object.entries(actionMap).reduce((accumulator, [key, ActionType]) => {\n        accumulator[key] = dispatch(ActionType);\n        return accumulator;\n    }, {});\n}\n\nfunction isWrappedDefaultExport(value) {\n    return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n    return isWrappedDefaultExport(input) ? input['default'] : input;\n}\nconst REGISTERED_PROVIDERS = new InjectionToken('', {\n    providedIn: 'root',\n    factory: () => {\n        const registeredProviders = new Set();\n        inject(ApplicationRef).onDestroy(() => registeredProviders.clear());\n        return registeredProviders;\n    }\n});\n/**\n * This function serves as a utility to lazy-load providers at the injection\n * context level — for example, at the route level. If the feature state needs\n * to be provided in more than one place, it might be indirectly included in\n * the main bundle, which we want to avoid. This function can be used at the\n * guard level to lazy-load the state provider before resolvers run and the\n * component is initialized:\n *\n * ```ts\n * const routes = [\n *   {\n *     path: 'home',\n *     loadComponent: () => import(...),\n *     canActivate: [\n *       lazyProvider(async () => (await import('path-to-state-library')).invoicesStateProvider)\n *     ]\n *   }\n * ];\n * ```\n *\n * Where `invoicesStateProvider` is the following:\n *\n * ```ts\n * // path-to-state-library/index.ts\n *\n * export const invoicesStateProvider = provideStates([InvoicesState]);\n * ```\n */\nfunction lazyProvider(factory) {\n    return async () => {\n        if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n            assertInInjectionContext(lazyProvider);\n        }\n        const appRef = inject(ApplicationRef);\n        const parentInjector = inject(EnvironmentInjector);\n        const registeredProviders = inject(REGISTERED_PROVIDERS);\n        const provider = maybeUnwrapDefaultExport(await factory());\n        if (registeredProviders.has(provider)) {\n            return true;\n        }\n        registeredProviders.add(provider);\n        const injector = createEnvironmentInjector([provider], parentInjector);\n        appRef.onDestroy(() => injector.destroy());\n        return true;\n    };\n}\n\n// Backward compatibility is provided because these tokens are used by third-party\n// libraries. We expose a separate function to allow tree-shaking of these tokens\n// if they are not used in standard applications that do not rely on them.\nfunction ɵprovideNgxsInternalStateTokens() {\n    return makeEnvironmentProviders([\n        {\n            provide: _NGXS_STATE_CONTEXT_FACTORY,\n            useExisting: StateContextFactory\n        },\n        {\n            provide: _NGXS_STATE_FACTORY,\n            useExisting: StateFactory\n        }\n    ]);\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, ActionDirector, ActionStatus, Actions, NgxsConfig, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NgxsUnhandledErrorHandler, Select, Selector, SelectorOptions, State, Store, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, lazyProvider, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPendingTasks, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule, ɵprovideNgxsInternalStateTokens };\n\n","import { UserModel } from \"../models/user.model\";\n\nexport class SetCurrentUserAction {\n  static readonly type = '[CurrentUser] Set Current User';\n  constructor(readonly payload: UserModel | null) { }\n}\nexport class RemoveCurrentUserAction {\n  static readonly type = '[CurrentUser] Remove Current User';\n  constructor() { }\n}\n"],"mappings":"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","names":["handlers","ActionStatus","config","noopAndWarn","Action"],"x_google_ignoreList":[0,1,2,3,4]}